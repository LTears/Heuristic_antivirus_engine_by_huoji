#include "head.h"
#include "analysis.h"
void analysis::log_function(uc_engine* uc, sim_process* process, std::string function_name, std::string moudle_name, uint64_t call_address, uint64_t function_address) {
	struct_process_trace_log log = {0};
	uint64_t rcx;
	log.function_address = function_address;
	log.call_address = call_address;
	log.params_num = 0;
	memcpy(log.function_name, function_name.c_str(), function_name.length());
	memcpy(log.moudle_name, moudle_name.c_str(), function_name.length());
	/*
	//不兼容x32
	for (size_t i = UC_X86_REG_INVALID; i < UC_X86_REG_ENDING; i++)
	{
		uint64_t reg_read;
		uc_reg_read(uc, i, &reg_read);
		log.save_regs.push_back(reg_read);
	}
	*/
	uc_reg_read(uc, UC_X86_REG_RCX, &rcx);
	if (function_name == "GetModuleHandleW") {
		log.params_num = 1;
		std::wstring moudle_name;
		std::string params_string;
		struct_params params = {0};
		if (tools::uc_read_wchar(uc, rcx, moudle_name))
		{
			params.type = PARAMS_WCHAR;
			memcpy(params.wstr, moudle_name.c_str(), moudle_name.length());
		}
		log.save_params.push_back(params);
	} else if (function_name == "system") {
		log.params_num = 1;
		std::string moudle_name;
		std::string params_string;
		struct_params params = { 0 };
		if (tools::uc_read_char(uc, rcx, moudle_name))
		{
			params.type = PARAMS_CHAR;
			memcpy(params.str, moudle_name.c_str(), moudle_name.length());
		}
		log.save_params.push_back(params);
	} else if (function_name == "exit" || function_name == "IsProcessorFeaturePresent") {
		log.params_num = 0;
		std::wstring moudle_name;
		std::string params_string;
		struct_params params = { 0 };
		params.type = function_name == "IsProcessorFeaturePresent" ? PARAMS_UINT : PARAMS_INT;
		params._int = rcx;
		log.save_params.push_back(params);
	}

	log.time = time(0);
	process->trace_log.push_back(log);
}
/*
	detailed 显示寄存器信息,没做 lazy
*/
void analysis::print_process_functions(sim_process* process, int detailed) {
	printf("\033[32m\t => call trace: \n");
	for (auto log_iter : process->trace_log)
	{
		std::string str_params = std::string("NULL");
		for (int i = 0; i < log_iter.save_params.size(); i++)
		{
			std::stringstream stream_cover;
			std::string params_type;
			std::string params_data;
			stream_cover << i;
			std::string _type = stream_cover.str();
			stream_cover = std::stringstream();
			std::string cover_string;
			switch (log_iter.save_params[i].type)
			{
				case PARAMS_INT:
					params_type = "int";
					stream_cover << log_iter.save_params[i]._int;
					break;
				case PARAMS_CHAR: 
					params_type = "char"; 
					stream_cover << log_iter.save_params[i].str;
					break;
				case PARAMS_WCHAR: 
					params_type = "wchar"; 
					tools::UnicodeToANSI(log_iter.save_params[i].wstr, cover_string);
					stream_cover << cover_string;
					break;
				case PARAMS_UINT: 
					params_type = "uint";
					stream_cover << "0x" <<std::hex << log_iter.save_params[i].uint;
					break;
				default: 
					params_type = "unknown";  
					stream_cover << "unknown";
					break;
			}
			str_params = _type + "{" + params_type + "}" + stream_cover.str() + " \n";
		}
		printf("\t%s.%s(%p) caller: %p params: %s \n", log_iter.moudle_name,log_iter.function_name,log_iter.function_address,log_iter.call_address, str_params.c_str());
	}
	printf("\033[0m");
}