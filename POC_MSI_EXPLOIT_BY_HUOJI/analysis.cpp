#include "head.h"
#include "analysis.h"
void analysis::log_function(uc_engine* uc, sim_process* process, std::string function_name, std::string moudle_name, uint64_t call_address, uint64_t function_address,int params_num_input, uint64_t code_size) {
	struct_process_trace_log log = {0};
	uint64_t params_1_address = 0;
	log.function_address = function_address;
	uint64_t test;
	uc_reg_read(uc, UC_X86_REG_ESP, &test);
	log.call_address = test;
	log.params_num = 0;
	memcpy(log.function_name, function_name.c_str(), function_name.length());
	memcpy(log.moudle_name, moudle_name.c_str(), function_name.length());
	if(process->is_x64)
		uc_reg_read(uc, UC_X86_REG_RCX, &params_1_address);
	else {
		uint64_t ebp_address = 0;
		uc_reg_read(uc, UC_X86_REG_ESP, &ebp_address);
		ebp_address += 0x4;
		uc_mem_read(uc, ebp_address, &params_1_address, 0x4);
	}
	if (function_name == "GetModuleHandleW" || function_name == "GetModuleHandleA") {
		log.params_num = 1;
		struct_params params = { 0 };
		if (params_1_address == NULL) {
			params.type = PARAMS_UINT;
			params.uint = NULL;
		}
		else {
			if (function_name == "GetModuleHandleW") {
				std::wstring moudle_name;
				std::string params_string;
				if (tools::uc_read_wchar(uc, params_1_address, moudle_name))
				{
					params.type = PARAMS_WCHAR;
					memcpy(params.wstr, moudle_name.c_str(), moudle_name.length());
				}
			}
			else {
				std::string moudle_name;
				std::string params_string;
				if (tools::uc_read_char(uc, params_1_address, moudle_name))
				{
					params.type = PARAMS_CHAR;
					memcpy(params.str, moudle_name.c_str(), moudle_name.length());
				}
			}
		}
		log.save_params.push_back(params);
	} else if (function_name == "system") {
		log.params_num = 1;
		std::string moudle_name;
		std::string params_string;
		struct_params params = { 0 };
		if (tools::uc_read_char(uc, params_1_address, moudle_name))
		{
			params.type = PARAMS_CHAR;
			memcpy(params.str, moudle_name.c_str(), moudle_name.length());
		}
		log.save_params.push_back(params);
	} else if (function_name == "exit" || function_name == "IsProcessorFeaturePresent") {
		log.params_num = 0;
		std::wstring moudle_name;
		std::string params_string;
		struct_params params = { 0 };
		params.type = function_name == "IsProcessorFeaturePresent" ? PARAMS_UINT : PARAMS_INT;
		params._int = params_1_address;
		log.save_params.push_back(params);
	}

	log.time = time(0);
	process->trace_log.push_back(log);
	
	if (params_num_input != -1) {
		//不执行函数
		uint64_t currt_rsp = 0;
		uint64_t return_address = 0;
		uc_reg_read(uc, process->is_x64 ? UC_X86_REG_RSP : UC_X86_REG_ESP, &currt_rsp);
		uc_mem_read(uc, currt_rsp, &return_address, process->is_x64 ? 0x8 : 0x4);
		uc_reg_write(uc, process->is_x64 ? UC_X86_REG_RIP : UC_X86_REG_EIP, &return_address);
		printf("return_address %p\n", return_address);
		//__debugbreak();
		uint64_t add_rsp = process->is_x64 == false ? (DWORD64)params_num_input : 0x8;
		currt_rsp += add_rsp;
		uc_reg_write(uc, process->is_x64 ? UC_X86_REG_RSP : UC_X86_REG_ESP, &currt_rsp);
	}
	
}
/*
	detailed 显示寄存器信息,没做 lazy
*/
void analysis::print_process_functions(sim_process* process, int detailed) {
	printf("\033[32m\t => call trace: \n");
	for (auto log_iter : process->trace_log)
	{
		std::string str_params = std::string("NULL");
		for (int i = 0; i < log_iter.save_params.size(); i++)
		{
			std::stringstream stream_cover;
			std::string params_type;
			std::string params_data;
			stream_cover << i;
			std::string _type = stream_cover.str();
			stream_cover = std::stringstream();
			std::string cover_string;
			switch (log_iter.save_params[i].type)
			{
				case PARAMS_INT:
					params_type = "int";
					stream_cover << log_iter.save_params[i]._int;
					break;
				case PARAMS_CHAR: 
					params_type = "char"; 
					stream_cover << log_iter.save_params[i].str;
					break;
				case PARAMS_WCHAR: 
					params_type = "wchar"; 
					tools::UnicodeToANSI(log_iter.save_params[i].wstr, cover_string);
					stream_cover << cover_string;
					break;
				case PARAMS_UINT: 
					params_type = "uint";
					stream_cover << "0x" <<std::hex << log_iter.save_params[i].uint;
					break;
				default: 
					params_type = "unknown";  
					stream_cover << "unknown";
					break;
			}
			str_params = _type + "{" + params_type + "}" + stream_cover.str() + " \n";
		}
		printf("\t%s.%s(%p) caller: %p params: %s \n", log_iter.moudle_name,log_iter.function_name,log_iter.function_address,log_iter.call_address, str_params.c_str());
	}
	printf("\033[0m");
}