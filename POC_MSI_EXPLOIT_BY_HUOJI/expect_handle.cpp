#include "expect_handle.h"
#include "head.h"
#include <ntstatus.h>
crt_buffer_t::crt_buffer_t() : m_cbSize(0), m_pBuffer(NULL)
{
}

crt_buffer_t::crt_buffer_t(size_t size) : m_cbSize(size), m_pBuffer(malloc(size))
{
}

crt_buffer_t::~crt_buffer_t()
{
	if (m_pBuffer)
		free(m_pBuffer);
}

void* crt_buffer_t::GetSpace(size_t needSize)
{
	if (m_cbSize < needSize)
	{
		if (m_pBuffer)
			m_pBuffer = realloc(m_pBuffer, needSize);
		else
			m_pBuffer = malloc(needSize);
		m_cbSize = needSize;
	}
	return m_pBuffer;
}
/*
	这异常处理,暂时没有考虑到wow64,,tm的到时候还要兼容wow64...司马32程序
*/
bool expect_handle::is_frame_in_bound(ULONG64 params_stack_frame, PULONG64 params_low_limit,  PULONG64 params_high_limit)
{
	if ((params_stack_frame & 0x7) != 0) {
		return false;
	}
	return ((params_stack_frame < *params_low_limit) || (params_stack_frame >= *params_high_limit)) == false;
	/*
	if ((params_stack_frame < *params_low_limit) ||
		(params_stack_frame >= *params_high_limit)) {
		return FALSE;
	}
	else {
		return TRUE;
	}
	*/
}
/*
	拷贝上下文
*/
void expect_handle::copy_context(PCONTEXT params_destination_context, PCONTEXT params_source_context) {
	params_destination_context->Rip = params_source_context->Rip;
	params_destination_context->Rbx = params_source_context->Rbx;
	params_destination_context->Rsp = params_source_context->Rsp;
	params_destination_context->Rbp = params_source_context->Rbp;
	params_destination_context->Rsi = params_source_context->Rsi;
	params_destination_context->Rdi = params_source_context->Rdi;
	params_destination_context->R12 = params_source_context->R12;
	params_destination_context->R13 = params_source_context->R13;
	params_destination_context->R14 = params_source_context->R14;
	params_destination_context->R15 = params_source_context->R15;
	params_destination_context->Xmm6 = params_source_context->Xmm6;
	params_destination_context->Xmm7 = params_source_context->Xmm7;
	params_destination_context->Xmm8 = params_source_context->Xmm8;
	params_destination_context->Xmm9 = params_source_context->Xmm9;
	params_destination_context->Xmm10 = params_source_context->Xmm10;
	params_destination_context->Xmm11 = params_source_context->Xmm11;
	params_destination_context->Xmm12 = params_source_context->Xmm12;
	params_destination_context->Xmm13 = params_source_context->Xmm13;
	params_destination_context->Xmm14 = params_source_context->Xmm14;
	params_destination_context->Xmm15 = params_source_context->Xmm15;
	params_destination_context->SegCs = params_source_context->SegCs;
	params_destination_context->SegSs = params_source_context->SegSs;
	params_destination_context->MxCsr = params_source_context->MxCsr;
	params_destination_context->EFlags = params_source_context->EFlags;
}

/*
	设置上下文
*/
void expect_handle::set_context(PCONTEXT params_context, sim_process params_process)
{
	uc_reg_write(g_global->uc_engine, UC_X86_REG_CS, &params_context->SegCs);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_DS, &params_context->SegDs);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_ES, &params_context->SegEs);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_SS, &params_context->SegSs);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_FS, &params_context->SegFs);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_GS, &params_context->SegGs);

	uc_reg_write(g_global->uc_engine, UC_X86_REG_RAX, &params_context->Rax);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_RBX, &params_context->Rbx);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_RCX, &params_context->Rcx);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_RDX, &params_context->Rdx);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_RSI, &params_context->Rsi);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_RDI, &params_context->Rdi);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_R8, &params_context->R8);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_R9, &params_context->R9);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_R10, &params_context->R10);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_R11, &params_context->R11);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_R12, &params_context->R12);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_R13, &params_context->R13);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_R14, &params_context->R14);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_R15, &params_context->R15);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_RBP, &params_context->Rbp);

	uc_reg_write(g_global->uc_engine, UC_X86_REG_XMM0, &params_context->Xmm0);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_XMM1, &params_context->Xmm1);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_XMM2, &params_context->Xmm2);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_XMM3, &params_context->Xmm3);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_XMM4, &params_context->Xmm4);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_XMM5, &params_context->Xmm5);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_XMM6, &params_context->Xmm6);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_XMM7, &params_context->Xmm7);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_XMM8, &params_context->Xmm8);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_XMM9, &params_context->Xmm9);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_XMM10, &params_context->Xmm10);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_XMM11, &params_context->Xmm11);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_XMM12, &params_context->Xmm12);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_XMM13, &params_context->Xmm13);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_XMM14, &params_context->Xmm14);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_XMM15, &params_context->Xmm15);

	uc_reg_write(g_global->uc_engine, UC_X86_REG_EFLAGS, &params_context->EFlags);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_RSP, &params_context->Rsp);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_RIP, &params_context->Rip);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_DR0, &params_context->Dr0);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_DR1, &params_context->Dr1);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_DR2, &params_context->Dr2);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_DR3, &params_context->Dr3);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_DR6, &params_context->Dr6);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_DR7, &params_context->Dr7);

	//少一个东西 m_ExecuteFromRip = ContextRecord->Rip;
}
/*
	得到上下文
*/
void expect_handle::capture_context(PCONTEXT params_context, sim_process params_process)
{
	uc_reg_read(g_global->uc_engine, UC_X86_REG_CS, &params_context->SegCs);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_DS, &params_context->SegDs);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_ES, &params_context->SegEs);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_SS, &params_context->SegSs);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_FS, &params_context->SegFs);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_GS, &params_context->SegGs);

	uc_reg_read(g_global->uc_engine, UC_X86_REG_RAX, &params_context->Rax);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_RBX, &params_context->Rbx);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_RCX, &params_context->Rcx);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_RDX, &params_context->Rdx);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_RSI, &params_context->Rsi);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_RDI, &params_context->Rdi);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_R8, &params_context->R8);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_R9, &params_context->R9);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_R10, &params_context->R10);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_R11, &params_context->R11);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_R12, &params_context->R12);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_R13, &params_context->R13);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_R14, &params_context->R14);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_R15, &params_context->R15);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_RBP, &params_context->Rbp);

	uc_reg_read(g_global->uc_engine, UC_X86_REG_XMM0, &params_context->Xmm0);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_XMM1, &params_context->Xmm1);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_XMM2, &params_context->Xmm2);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_XMM3, &params_context->Xmm3);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_XMM4, &params_context->Xmm4);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_XMM5, &params_context->Xmm5);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_XMM6, &params_context->Xmm6);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_XMM7, &params_context->Xmm7);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_XMM8, &params_context->Xmm8);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_XMM9, &params_context->Xmm9);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_XMM10, &params_context->Xmm10);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_XMM11, &params_context->Xmm11);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_XMM12, &params_context->Xmm12);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_XMM13, &params_context->Xmm13);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_XMM14, &params_context->Xmm14);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_XMM15, &params_context->Xmm15);

	uc_reg_read(g_global->uc_engine, UC_X86_REG_RIP, &params_context->Rip);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_RSP, &params_context->Rsp);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_EFLAGS, &params_context->EFlags);

	uc_reg_read(g_global->uc_engine, UC_X86_REG_DR0, &params_context->Dr0);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_DR1, &params_context->Dr1);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_DR2, &params_context->Dr2);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_DR3, &params_context->Dr3);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_DR6, &params_context->Dr6);
	uc_reg_read(g_global->uc_engine, UC_X86_REG_DR7, &params_context->Dr7);

	params_context->ContextFlags = CONTEXT_FULL;
}

void expect_handle::get_stack_limit(PULONG64 params_low_limit, PULONG64 params_highlimit, sim_process params_process)
{
	*params_low_limit = params_process.context.m_stack_base;
	*params_highlimit = params_process.context.m_stack_end;
}
/*
	如果不是直接寻址的(FunctionEntryCell.UnwindData & RUNTIME_FUNCTION_INDIRECT不是0),转为直接寻址,如果是直接寻址,直接返回
*/
PRUNTIME_FUNCTION expect_handle::convert_function_entry(IN PRUNTIME_FUNCTION params_function_address,IN ULONG64 params_image_base)
{
	if (params_function_address) {
		RUNTIME_FUNCTION FunctionEntryCell;
		uc_mem_read(g_global->uc_engine, (uint64_t)params_function_address, &FunctionEntryCell, sizeof(FunctionEntryCell));
		if ((FunctionEntryCell.UnwindData & RUNTIME_FUNCTION_INDIRECT) != 0) {
			params_function_address = (PRUNTIME_FUNCTION)(FunctionEntryCell.UnwindData + params_image_base - 1);
		}
	}
	return params_function_address;
}
/*
	找runtime function表
*/
PRUNTIME_FUNCTION expect_handle::lookup_runtime_function_table(ULONG64 params_exception_address,sim_process params_process)
{
	ULONG64 BaseAddress;
	ULONG64 BeginAddress;
	ULONG64 EndAddress;
	PRUNTIME_FUNCTION FunctionEntry = NULL;
	PRUNTIME_FUNCTION FunctionTable = NULL;
	LONG High;
	ULONG Index;
	LONG Low;
	LONG Middle;
	ULONG RelativePc;
	ULONG SizeOfTable;
	/*
		如果history_table没有我们想要的信息,
		遍历KLDR_DATA_TABLE_ENTRY->ExceptionTable 结构,然后存到history_table里面 @hzqst 你的代码里面前面那一大段都是摆设应该给history_table存进去的找到后
		这里我们只关心自己的SEH 不处理其他模块给我们装的东西
	*/
	auto uc_error = uc_mem_read(g_global->uc_engine, (params_process.m_image_base + params_process.exception_table_base), FunctionTable, params_process.exception_table_size);
	if (uc_error != UC_ERR_OK)
		__debugbreak();
	__debugbreak();
	if (FunctionTable != NULL) {
		Low = 0;
		High = (SizeOfTable / sizeof(RUNTIME_FUNCTION)) - 1;
		RelativePc = (ULONG)(params_exception_address - params_process.m_image_base);
		while (High >= Low) {
			/*
				try catch会有很多个嵌套,找到最里面的那个!
			*/
			Middle = (Low + High) >> 1;
			FunctionEntry = &FunctionTable[Middle];

			RUNTIME_FUNCTION FunctionEntryCell;
			uc_mem_read(g_global->uc_engine, (uint64_t)FunctionEntry, &FunctionEntryCell, sizeof(FunctionEntryCell));

			if (RelativePc < FunctionEntryCell.BeginAddress) {
				High = Middle - 1;

			}
			else if (RelativePc >= FunctionEntryCell.EndAddress) {
				Low = Middle + 1;
			}
			else {
				break;
			}
		}

		if (High < Low) {
			FunctionEntry = NULL;
		}

	}
	else {
		FunctionEntry = NULL;
	}
	//找到了给history table插东西,但是我们这边不处理history table
	//....
	//finished
	return convert_function_entry(FunctionEntry, params_process.m_image_base);
}

PUNWIND_INFO expect_handle::RtlpLookupPrimaryUnwindInfo(IN PRUNTIME_FUNCTION FunctionEntry,IN ULONG64 ImageBase,OUT PRUNTIME_FUNCTION* PrimaryEntry, sim_process params_process)
{

	ULONG Index;
	PUNWIND_INFO UnwindInfo;
	RUNTIME_FUNCTION FunctionEntryCell;
	uc_mem_read(g_global->uc_engine, (uint64_t)FunctionEntry, &FunctionEntryCell, sizeof(FunctionEntryCell));

	//
	// Locate the unwind information and determine whether it is chained.
	// If the unwind information is chained, then locate the parent function
	// entry and loop again.
	//

	do {
		UnwindInfo = (PUNWIND_INFO)(FunctionEntryCell.UnwindData + ImageBase);

		crt_buffer_t UnwindInfoCell(offsetof(UNWIND_INFO, UnwindCode));
		uc_mem_read(g_global->uc_engine, (uint64_t)UnwindInfo, UnwindInfoCell.GetBuffer(), UnwindInfoCell.GetLength());
		PUNWIND_INFO UnwindInfoCellPtr = (PUNWIND_INFO)UnwindInfoCell.GetBuffer();
		UnwindInfoCell.GetSpace(offsetof(UNWIND_INFO, UnwindCode) + UnwindInfoCellPtr->CountOfCodes * sizeof(UNWIND_CODE));
		uc_mem_read(g_global->uc_engine, (uint64_t)UnwindInfo, UnwindInfoCell.GetBuffer(), UnwindInfoCell.GetLength());
		UnwindInfoCellPtr = (PUNWIND_INFO)UnwindInfoCell.GetBuffer();

		if ((UnwindInfoCellPtr->Flags & UNW_FLAG_CHAININFO) == 0) {
			break;
		}

		Index = UnwindInfoCellPtr->CountOfCodes;
		if ((Index & 1) != 0) {
			Index += 1;
		}

		FunctionEntry = (PRUNTIME_FUNCTION)&UnwindInfoCellPtr->UnwindCode[Index];
	} while (TRUE);

	*PrimaryEntry = FunctionEntry;
	return UnwindInfo;
}
PRUNTIME_FUNCTION expect_handle::FakeRtlpSameFunction(IN PRUNTIME_FUNCTION FunctionEntry,IN ULONG64 ImageBase,IN ULONG64 ControlPc, sim_process params_process)
{

	PRUNTIME_FUNCTION PrimaryFunctionEntry;
	PRUNTIME_FUNCTION TargetFunctionEntry;
	ULONG64 TargetImageBase;
	PUNWIND_INFO UnwindInfo1;
	PUNWIND_INFO UnwindInfo2;

	//
	// Lookup the primary function entry associated with the specified
	// function entry.
	// 

	UnwindInfo1 = RtlpLookupPrimaryUnwindInfo(FunctionEntry,ImageBase,&PrimaryFunctionEntry, params_process);

	//
	// Determine the function entry containing the control Pc and similarly
	// resolve its primary function entry.  If no function entry can be
	// found then the control pc resides in a different function.
	//

	TargetFunctionEntry = lookup_runtime_function_table(ControlPc, params_process);

	if (TargetFunctionEntry == NULL) {
		return NULL;
	}

	//
	// Lookup the primary function entry associated with the target function
	// entry.
	//

	UnwindInfo2 = RtlpLookupPrimaryUnwindInfo(TargetFunctionEntry, TargetImageBase, &PrimaryFunctionEntry, params_process);

	//
	// If the address of the two sets of unwind information are equal, then
	// return the address of the primary function entry. Otherwise, return
	// NULL.
	//

	if (UnwindInfo1 == UnwindInfo2) {
		return PrimaryFunctionEntry;

	}
	else {
		return NULL;
	}
}

PRUNTIME_FUNCTION expect_handle::FakeRtlpUnwindPrologue(IN ULONG64 ImageBase,IN ULONG64 ControlPc,IN ULONG64 FrameBase,IN PRUNTIME_FUNCTION FunctionEntry,IN OUT PCONTEXT ContextRecord,IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL,sim_process params_process)
{

	PM128A FloatingAddress;
	PM128A FloatingRegister;
	ULONG FrameOffset;
	ULONG Index;
	PULONG64 IntegerAddress;
	PULONG64 IntegerRegister;
	BOOLEAN MachineFrame;
	ULONG OpInfo;
	ULONG PrologOffset;
	PULONG64 RegisterAddress;
	PULONG64 ReturnAddress;
	PULONG64 StackAddress;
	PUNWIND_CODE UnwindCode;
	PUNWIND_INFO UnwindInfo;
	ULONG UnwindOp;
	uint64_t ValueFromAddress;

	//
	// Process the unwind codes.
	//

	FloatingRegister = &ContextRecord->Xmm0;
	IntegerRegister = &ContextRecord->Rax;
	Index = 0;
	MachineFrame = FALSE;

	RUNTIME_FUNCTION FunctionEntryCell;
	uc_mem_read(g_global->uc_engine, (uint64_t)FunctionEntry, &FunctionEntryCell, sizeof(FunctionEntryCell));

	PrologOffset = (ULONG)(ControlPc - (FunctionEntryCell.BeginAddress + ImageBase));
	UnwindInfo = (PUNWIND_INFO)(FunctionEntryCell.UnwindData + ImageBase);

	crt_buffer_t UnwindInfoCell(offsetof(UNWIND_INFO, UnwindCode));
	uc_mem_read(g_global->uc_engine, (uint64_t)UnwindInfo, UnwindInfoCell.GetBuffer(), UnwindInfoCell.GetLength());
	PUNWIND_INFO UnwindInfoCellPtr = (PUNWIND_INFO)UnwindInfoCell.GetBuffer();
	UnwindInfoCell.GetSpace(offsetof(UNWIND_INFO, UnwindCode) + UnwindInfoCellPtr->CountOfCodes * sizeof(UNWIND_CODE) + sizeof(DWORD) * 2);
	uc_mem_read(g_global->uc_engine, (uint64_t)UnwindInfo, UnwindInfoCell.GetBuffer(), UnwindInfoCell.GetLength());
	UnwindInfoCellPtr = (PUNWIND_INFO)UnwindInfoCell.GetBuffer();

	while (Index < UnwindInfoCellPtr->CountOfCodes) {

		//
		// If the prologue offset is greater than the next unwind code offset,
		// then simulate the effect of the unwind code.
		//

		UnwindOp = UnwindInfoCellPtr->UnwindCode[Index].UnwindOp;
		OpInfo = UnwindInfoCellPtr->UnwindCode[Index].OpInfo;
		if (PrologOffset >= UnwindInfoCellPtr->UnwindCode[Index].CodeOffset) {
			switch (UnwindOp) {

				//
				// Push nonvolatile integer register.
				//
				// The operation information is the register number of the
				// register than was pushed.
				//

			case UWOP_PUSH_NONVOL:
				IntegerAddress = (PULONG64)(ContextRecord->Rsp);

				uc_mem_read(g_global->uc_engine, (uint64_t)IntegerAddress, &ValueFromAddress, sizeof(ValueFromAddress));

				IntegerRegister[OpInfo] = ValueFromAddress;
				if (ContextPointers) {
					ContextPointers->IntegerContext[OpInfo] = IntegerAddress;
				}

				ContextRecord->Rsp += 8;
				break;

				//
				// Allocate a large sized area on the stack.
				//
				// The operation information determines if the size is
				// 16- or 32-bits.
				//

			case UWOP_ALLOC_LARGE:
				Index += 1;
				FrameOffset = UnwindInfoCellPtr->UnwindCode[Index].FrameOffset;
				if (OpInfo != 0) {
					Index += 1;
					FrameOffset += (UnwindInfoCellPtr->UnwindCode[Index].FrameOffset << 16);

				}
				else {
					FrameOffset *= 8;
				}

				ContextRecord->Rsp += FrameOffset;
				break;

				//
				// Allocate a small sized area on the stack.
				//
				// The operation information is the size of the unscaled
				// allocation size (8 is the scale factor) minus 8.
				//

			case UWOP_ALLOC_SMALL:
				ContextRecord->Rsp += (OpInfo * 8) + 8;
				break;

				//
				// Establish the the frame pointer register.
				//
				// The operation information is not used.
				//

			case UWOP_SET_FPREG:
				ContextRecord->Rsp = IntegerRegister[UnwindInfoCellPtr->FrameRegister];
				ContextRecord->Rsp -= UnwindInfoCellPtr->FrameOffset * 16;
				break;

				//
				// Save nonvolatile integer register on the stack using a
				// 16-bit displacment.
				//
				// The operation information is the register number.
				//

			case UWOP_SAVE_NONVOL:
				Index += 1;
				FrameOffset = UnwindInfoCellPtr->UnwindCode[Index].FrameOffset * 8;
				IntegerAddress = (PULONG64)(FrameBase + FrameOffset);

				uc_mem_read(g_global->uc_engine, (uint64_t)IntegerAddress, &ValueFromAddress, sizeof(ValueFromAddress));

				IntegerRegister[OpInfo] = ValueFromAddress;
				if (ContextPointers) {
					ContextPointers->IntegerContext[OpInfo] = IntegerAddress;
				}

				break;

				//
				// Save nonvolatile integer register on the stack using a
				// 32-bit displacment.
				//
				// The operation information is the register number.
				//

			case UWOP_SAVE_NONVOL_FAR:
				Index += 2;
				FrameOffset = UnwindInfoCellPtr->UnwindCode[Index - 1].FrameOffset;
				FrameOffset += (UnwindInfoCellPtr->UnwindCode[Index].FrameOffset << 16);
				IntegerAddress = (PULONG64)(FrameBase + FrameOffset);
				uc_mem_read(g_global->uc_engine, (uint64_t)IntegerAddress, &ValueFromAddress, sizeof(ValueFromAddress));
				IntegerRegister[OpInfo] = ValueFromAddress;
				if (ContextPointers) {
					ContextPointers->IntegerContext[OpInfo] = IntegerAddress;
				}

				break;

				//
				// Spare unused codes.
				//

			case UWOP_SPARE_CODE1:
			case UWOP_SPARE_CODE2:

				break;

				//
				// Save a nonvolatile XMM(128) register on the stack using a
				// 16-bit displacement.
				//
				// The operation information is the register number.
				//

			case UWOP_SAVE_XMM128:
				Index += 1;
				FrameOffset = UnwindInfoCellPtr->UnwindCode[Index].FrameOffset * 16;
				FloatingAddress = (PM128A)(FrameBase + FrameOffset);
				FloatingRegister[OpInfo].Low = FloatingAddress->Low;
				FloatingRegister[OpInfo].High = FloatingAddress->High;
				if (ContextPointers) {
					ContextPointers->FloatingContext[OpInfo] = FloatingAddress;
				}

				break;

				//
				// Save a nonvolatile XMM(128) register on the stack using a
				// 32-bit displacement.
				//
				// The operation information is the register number.
				//

			case UWOP_SAVE_XMM128_FAR:
				Index += 2;
				FrameOffset = UnwindInfoCellPtr->UnwindCode[Index - 1].FrameOffset;
				FrameOffset += (UnwindInfoCellPtr->UnwindCode[Index].FrameOffset << 16);
				FloatingAddress = (PM128A)(FrameBase + FrameOffset);
				FloatingRegister[OpInfo].Low = FloatingAddress->Low;
				FloatingRegister[OpInfo].High = FloatingAddress->High;
				if (ContextPointers) {
					ContextPointers->FloatingContext[OpInfo] = FloatingAddress;
				}

				break;

				//
				// Push a machine frame on the stack.
				//
				// The operation information determines whether the machine
				// frame contains an error code or not.
				//

			case UWOP_PUSH_MACHFRAME:
				MachineFrame = TRUE;
				ReturnAddress = (PULONG64)(ContextRecord->Rsp);
				StackAddress = (PULONG64)(ContextRecord->Rsp + (3 * 8));
				if (OpInfo != 0) {
					ReturnAddress += 1;
					StackAddress += 1;
				}

				uc_mem_read(g_global->uc_engine, (uint64_t)ReturnAddress, &ValueFromAddress, sizeof(ValueFromAddress));

				ContextRecord->Rip = ValueFromAddress;

				uc_mem_read(g_global->uc_engine, (uint64_t)StackAddress, &ValueFromAddress, sizeof(ValueFromAddress));

				ContextRecord->Rsp = ValueFromAddress;
				break;

				//
				// Unused codes.
				//

			default:

				break;
			}

			Index += 1;

		}
		else {

			//
			// Skip this unwind operation by advancing the slot index by the
			// number of slots consumed by this operation.
			//

			Index += params_process.m_RtlpUnwindOpSlotTable[UnwindOp];

			//
			// Special case any unwind operations that can consume a variable
			// number of slots.
			// 

			switch (UnwindOp) {

				//
				// A non-zero operation information indicates that an
				// additional slot is consumed.
				//

			case UWOP_ALLOC_LARGE:
				if (OpInfo != 0) {
					Index += 1;
				}

				break;

				//
				// No other special cases.
				//

			default:
				break;
			}
		}
	}

	//
	// If chained unwind information is specified, then recursively unwind
	// the chained information. Otherwise, determine the return address if
	// a machine frame was not encountered during the scan of the unwind
	// codes.
	//

	if ((UnwindInfoCellPtr->Flags & UNW_FLAG_CHAININFO) != 0) {
		Index = UnwindInfoCellPtr->CountOfCodes;
		if ((Index & 1) != 0) {
			Index += 1;
		}

		FunctionEntry = (PRUNTIME_FUNCTION)(&UnwindInfoCellPtr->UnwindCode[Index]);
		return FakeRtlpUnwindPrologue(ImageBase,
			ControlPc,
			FrameBase,
			FunctionEntry,
			ContextRecord,
			ContextPointers,
			params_process);

	}
	else {
		if (MachineFrame == FALSE) {

			uint64_t ValueFromAddress;
			uc_mem_read(g_global->uc_engine, (uint64_t)ContextRecord->Rsp, &ValueFromAddress, sizeof(ValueFromAddress));

			ContextRecord->Rip = ValueFromAddress;
			ContextRecord->Rsp += 8;
		}

		return FunctionEntry;
	}
}
/*
	windows异常的核心处理函数,作用是执行虚拟展开unwind的操作,然后返回PEXCEPTION_ROUTINE信息
*/
PEXCEPTION_ROUTINE expect_handle::FakeRtlVirtualUnwind(IN ULONG HandlerType,IN ULONG64 ImageBase,IN ULONG64 ControlPc,IN PRUNTIME_FUNCTION FunctionEntry,IN OUT PCONTEXT ContextRecord,OUT PVOID* HandlerData,OUT PULONG64 EstablisherFrame,IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL, sim_process params_process)
{
	ULONG64 BranchBase;
	ULONG64 BranchTarget;
	LONG Displacement;
	ULONG FrameRegister;
	ULONG Index;
	bool InEpilogue;
	PULONG64 IntegerAddress;
	PULONG64 IntegerRegister;
	PUCHAR NextByte;
	PRUNTIME_FUNCTION PrimaryFunctionEntry;
	ULONG PrologOffset;
	ULONG RegisterNumber;
	PUNWIND_INFO UnwindInfo;
	uint64_t ValueFromAddress;

	RUNTIME_FUNCTION FunctionEntryCell;
	uc_mem_read(g_global->uc_engine, (uint64_t)FunctionEntry, &FunctionEntryCell, sizeof(FunctionEntryCell));

	UnwindInfo = (PUNWIND_INFO)(FunctionEntryCell.UnwindData + ImageBase);
	PrologOffset = (ULONG)(ControlPc - (FunctionEntryCell.BeginAddress + ImageBase));

	crt_buffer_t UnwindInfoCell(offsetof(UNWIND_INFO, UnwindCode));
	uc_mem_read(g_global->uc_engine, (uint64_t)UnwindInfo, UnwindInfoCell.GetBuffer(), UnwindInfoCell.GetLength());
	PUNWIND_INFO UnwindInfoCellPtr = (PUNWIND_INFO)UnwindInfoCell.GetBuffer();
	UnwindInfoCell.GetSpace(offsetof(UNWIND_INFO, UnwindCode) + UnwindInfoCellPtr->CountOfCodes * sizeof(UNWIND_CODE) + sizeof(DWORD) * 2);
	uc_mem_read(g_global->uc_engine, (uint64_t)UnwindInfo, UnwindInfoCell.GetBuffer(), UnwindInfoCell.GetLength());
	UnwindInfoCellPtr = (PUNWIND_INFO)UnwindInfoCell.GetBuffer();

	if (UnwindInfoCellPtr->FrameRegister == 0) {
		*EstablisherFrame = ContextRecord->Rsp;

	}
	else if ((PrologOffset >= UnwindInfoCellPtr->SizeOfProlog) ||
		((UnwindInfoCellPtr->Flags & UNW_FLAG_CHAININFO) != 0)) {

		*EstablisherFrame = (&ContextRecord->Rax)[UnwindInfoCellPtr->FrameRegister];
		*EstablisherFrame -= UnwindInfoCellPtr->FrameOffset * 16;

	}
	else {
		Index = 0;
		while (Index < UnwindInfo->CountOfCodes) {
			if (UnwindInfoCellPtr->UnwindCode[Index].UnwindOp == UWOP_SET_FPREG) {
				break;
			}

			Index += 1;
		}

		if (PrologOffset >= UnwindInfoCellPtr->UnwindCode[Index].CodeOffset) {
			*EstablisherFrame = (&ContextRecord->Rax)[UnwindInfoCellPtr->FrameRegister];
			*EstablisherFrame -= UnwindInfoCellPtr->FrameOffset * 16;

		}
		else {
			*EstablisherFrame = ContextRecord->Rsp;
		}
	}

	//
	// If the point at which control left the specified function is in an
	// epilogue, then emulate the execution of the epilogue forward and
	// return no exception handler.
	//

	IntegerRegister = &ContextRecord->Rax;

	NextByte = (PUCHAR)ControlPc;

	UCHAR NextByteBuffer[15];
	uc_mem_read(g_global->uc_engine, (uint64_t)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
	//
	// Check for one of:
	//
	//   add rsp, imm8
	//       or
	//   add rsp, imm32
	//       or
	//   lea rsp, -disp8[fp]
	//       or
	//   lea rsp, -disp32[fp]
	//

	if ((NextByteBuffer[0] == SIZE64_PREFIX) &&
		(NextByteBuffer[1] == ADD_IMM8_OP) &&
		(NextByteBuffer[2] == 0xc4)) {

		//
		// add rsp, imm8.
		//

		NextByte += 4;
		uc_mem_read(g_global->uc_engine, (uint64_t)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
	}
	else if ((NextByteBuffer[0] == SIZE64_PREFIX) &&
		(NextByteBuffer[1] == ADD_IMM32_OP) &&
		(NextByteBuffer[2] == 0xc4)) {

		//
		// add rsp, imm32.
		//

		NextByte += 7;
		uc_mem_read(g_global->uc_engine, (uint64_t)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
	}
	else if (((NextByteBuffer[0] & 0xfe) == SIZE64_PREFIX) &&
		(NextByteBuffer[1] == LEA_OP)) {

		FrameRegister = ((NextByteBuffer[0] & 0x1) << 3) | (NextByteBuffer[2] & 0x7);
		if ((FrameRegister != 0) &&
			(FrameRegister == UnwindInfoCellPtr->FrameRegister)) {

			if ((NextByteBuffer[2] & 0xf8) == 0x60) {

				//
				// lea rsp, disp8[fp].
				//

				NextByte += 4;
				uc_mem_read(g_global->uc_engine, (uint64_t)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
			}
			else if ((NextByteBuffer[2] & 0xf8) == 0xa0) {

				//
				// lea rsp, disp32[fp].
				//

				NextByte += 7;
				uc_mem_read(g_global->uc_engine, (uint64_t)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
			}
		}
	}

	//
	// Check for any number of:
	//
	//   pop nonvolatile-integer-register[0..15].
	//

	while (TRUE) {
		if ((NextByteBuffer[0] & 0xf8) == POP_OP) {
			NextByte += 1;
			uc_mem_read(g_global->uc_engine, (uint64_t)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
		}
		else if (IS_REX_PREFIX(NextByteBuffer[0]) &&
			((NextByteBuffer[1] & 0xf8) == POP_OP)) {

			NextByte += 2;
			uc_mem_read(g_global->uc_engine, (uint64_t)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
		}
		else {
			break;
		}
	}

	//
	// If the next instruction is a return or an appropriate jump, then
	// control is currently in an epilogue and execution of the epilogue
	// should be emulated. Otherwise, execution is not in an epilogue and
	// the prologue should be unwound.
	//

	InEpilogue = FALSE;
	if ((NextByteBuffer[0] == RET_OP) ||
		(NextByteBuffer[0] == RET_OP_2) ||
		((NextByteBuffer[0] == REP_PREFIX) && (NextByteBuffer[1] == RET_OP))) {

		//
		// A return is an unambiguous indication of an epilogue.
		//

		InEpilogue = TRUE;

	}
	else if ((NextByteBuffer[0] == JMP_IMM8_OP) || (NextByteBuffer[0] == JMP_IMM32_OP)) {

		//
		// An unconditional branch to a target that is equal to the start of
		// or outside of this routine is logically a call to another function.
		// 

		BranchTarget = (ULONG64)NextByte - ImageBase;
		if (NextByteBuffer[0] == JMP_IMM8_OP) {
			BranchTarget += 2 + (CHAR)NextByteBuffer[1];

		}
		else {
			BranchTarget += 5 + *((LONG UNALIGNED*) & NextByteBuffer[1]);
		}

		//
		// Determine whether the branch target refers to code within this
		// function. If not, then it is an epilogue indicator.
		//
		// A branch to the start of self implies a recursive call, so
		// is treated as an epilogue.
		//

		if (BranchTarget < FunctionEntryCell.BeginAddress ||
			BranchTarget >= FunctionEntryCell.EndAddress) {

			//
			// The branch target is outside of the region described by
			// this function entry. See whether it is contained within
			// an indirect function entry associated with this same
			// function.
			//
			// If not, then the branch target really is outside of
			// this function.
			//

			PrimaryFunctionEntry = FakeRtlpSameFunction(FunctionEntry,
				ImageBase,
				BranchTarget + ImageBase, params_process);

			RUNTIME_FUNCTION PrimaryFunctionEntryCell;
			uc_mem_read(g_global->uc_engine, (uint64_t)PrimaryFunctionEntry, &PrimaryFunctionEntryCell, sizeof(PrimaryFunctionEntryCell));

			if ((PrimaryFunctionEntry == NULL) ||
				(BranchTarget == PrimaryFunctionEntryCell.BeginAddress)) {

				InEpilogue = TRUE;
			}

		}
		else if ((BranchTarget == FunctionEntryCell.BeginAddress) &&
			((UnwindInfoCellPtr->Flags & UNW_FLAG_CHAININFO) == 0)) {

			InEpilogue = TRUE;
		}

	}
	else if ((NextByteBuffer[0] == JMP_IND_OP) && (NextByteBuffer[1] == 0x25)) {

		//
		// An unconditional jump indirect.
		//
		// This is a jmp outside of the function, probably a tail call
		// to an import function.
		//

		InEpilogue = TRUE;

	}
	else if (((NextByteBuffer[0] & 0xf8) == SIZE64_PREFIX) &&
		(NextByteBuffer[1] == 0xff) &&
		(NextByteBuffer[2] & 0x38) == 0x20) {

		//
		// This is an indirect jump opcode: 0x48 0xff /4.  The 64-bit
		// flag (REX.W) is always redundant here, so its presence is
		// overloaded to indicate a branch out of the function - a tail
		// call.
		//
		// Such an opcode is an unambiguous epilogue indication.
		//

		InEpilogue = TRUE;
	}

	if (InEpilogue != FALSE) {
		NextByte = (PUCHAR)ControlPc;
		uc_mem_read(g_global->uc_engine, (uint64_t)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
		//
		// Emulate one of (if any):
		//
		//   add rsp, imm8
		//       or
		//   add rsp, imm32
		//       or                
		//   lea rsp, disp8[frame-register]
		//       or
		//   lea rsp, disp32[frame-register]
		//

		if ((NextByteBuffer[0] & 0xf8) == SIZE64_PREFIX) {

			if (NextByteBuffer[1] == ADD_IMM8_OP) {

				//
				// add rsp, imm8.
				//

				ContextRecord->Rsp += (CHAR)NextByteBuffer[3];
				NextByte += 4;
				uc_mem_read(g_global->uc_engine, (uint64_t)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
			}
			else if (NextByteBuffer[1] == ADD_IMM32_OP) {

				//
				// add rsp, imm32.
				//

				Displacement = NextByteBuffer[3] | (NextByteBuffer[4] << 8);
				Displacement |= (NextByteBuffer[5] << 16) | (NextByteBuffer[6] << 24);
				ContextRecord->Rsp += Displacement;
				NextByte += 7;
				uc_mem_read(g_global->uc_engine, (uint64_t)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
			}
			else if (NextByteBuffer[1] == LEA_OP) {
				if ((NextByteBuffer[2] & 0xf8) == 0x60) {

					//
					// lea rsp, disp8[frame-register].
					//

					ContextRecord->Rsp = IntegerRegister[FrameRegister];
					ContextRecord->Rsp += (CHAR)NextByteBuffer[3];
					NextByte += 4;
					uc_mem_read(g_global->uc_engine, (uint64_t)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
				}
				else if ((NextByteBuffer[2] & 0xf8) == 0xa0) {

					//
					// lea rsp, disp32[frame-register].
					//

					Displacement = NextByteBuffer[3] | (NextByteBuffer[4] << 8);
					Displacement |= (NextByteBuffer[5] << 16) | (NextByteBuffer[6] << 24);
					ContextRecord->Rsp = IntegerRegister[FrameRegister];
					ContextRecord->Rsp += Displacement;
					NextByte += 7;
					uc_mem_read(g_global->uc_engine, (uint64_t)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
				}
			}
		}

		//
		// Emulate any number of (if any):
		//
		//   pop nonvolatile-integer-register.
		//

		while (TRUE) {
			if ((NextByteBuffer[0] & 0xf8) == POP_OP) {

				//
				// pop nonvolatile-integer-register[0..7]
				//

				RegisterNumber = NextByteBuffer[0] & 0x7;

				IntegerAddress = (PULONG64)ContextRecord->Rsp;

				uint64_t ValueFromAddress;
				uc_mem_read(g_global->uc_engine, (uint64_t)IntegerAddress, &ValueFromAddress, sizeof(ValueFromAddress));

				IntegerRegister[RegisterNumber] = ValueFromAddress;
				if (ContextPointers) {
					ContextPointers->IntegerContext[RegisterNumber] = IntegerAddress;
				}

				ContextRecord->Rsp += 8;
				NextByte += 1;

			}
			else if (IS_REX_PREFIX(NextByteBuffer[0]) &&
				((NextByteBuffer[1] & 0xf8) == POP_OP)) {

				//
				// pop nonvolatile-integer-register[8..15]
				//

				RegisterNumber = ((NextByteBuffer[0] & 1) << 3) | (NextByteBuffer[1] & 0x7);

				IntegerAddress = (PULONG64)ContextRecord->Rsp;

				uc_mem_read(g_global->uc_engine, (uint64_t)IntegerAddress, &ValueFromAddress, sizeof(ValueFromAddress));

				IntegerRegister[RegisterNumber] = ValueFromAddress;

				if (ContextPointers) {
					ContextPointers->IntegerContext[RegisterNumber] = IntegerAddress;
				}

				ContextRecord->Rsp += 8;
				NextByte += 2;
				uc_mem_read(g_global->uc_engine, (uint64_t)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
			}
			else {
				break;
			}
		}

		//
		// Emulate return and return null exception handler.
		//
		// Note: this instruction might in fact be a jmp, however
		//       we want to emulate a return regardless.
		//

		uint64_t ValueFromRsp;
		uc_mem_read(g_global->uc_engine, (uint64_t)ContextRecord->Rsp, &ValueFromRsp, sizeof(ValueFromRsp));
		ContextRecord->Rip = ValueFromRsp;
		ContextRecord->Rsp += 8;
		return NULL;
	}

	//
	// Control left the specified function outside an epilogue. Unwind the
	// subject function and any chained unwind information.
	//

	FunctionEntry = FakeRtlpUnwindPrologue(ImageBase,
		ControlPc,
		*EstablisherFrame,
		FunctionEntry,
		ContextRecord,
		ContextPointers,
		params_process);

	uc_mem_read(g_global->uc_engine, (uint64_t)FunctionEntry, &FunctionEntryCell, sizeof(FunctionEntryCell));

	//
	// If control left the specified function outside of the prologue and
	// the function has a handler that matches the specified type, then
	// return the address of the language specific exception handler.
	// Otherwise, return NULL.
	//

	UnwindInfo = (PUNWIND_INFO)(FunctionEntryCell.UnwindData + ImageBase);

	uc_mem_read(g_global->uc_engine, (uint64_t)UnwindInfo, UnwindInfoCell.GetBuffer(), UnwindInfoCell.GetLength());
	UnwindInfoCellPtr = (PUNWIND_INFO)UnwindInfoCell.GetBuffer();
	UnwindInfoCell.GetSpace(offsetof(UNWIND_INFO, UnwindCode) + UnwindInfoCellPtr->CountOfCodes * sizeof(UNWIND_CODE) + sizeof(DWORD) * 2);
	uc_mem_read(g_global->uc_engine, (uint64_t)UnwindInfo, UnwindInfoCell.GetBuffer(), UnwindInfoCell.GetLength());
	UnwindInfoCellPtr = (PUNWIND_INFO)UnwindInfoCell.GetBuffer();

	PrologOffset = (ULONG)(ControlPc - (FunctionEntryCell.BeginAddress + ImageBase));
	if ((PrologOffset >= UnwindInfoCellPtr->SizeOfProlog) &&
		((UnwindInfoCellPtr->Flags & HandlerType) != 0)) {
		Index = UnwindInfoCellPtr->CountOfCodes;
		if ((Index & 1) != 0) {
			Index += 1;
		}

		*HandlerData = (PVOID)((PUCHAR)UnwindInfo + ((PUCHAR)&UnwindInfoCellPtr->UnwindCode[Index + 2] - (PUCHAR)UnwindInfoCellPtr));
		return (PEXCEPTION_ROUTINE)(*((PULONG)&UnwindInfoCellPtr->UnwindCode[Index]) + ImageBase);

	}
	else {
		return NULL;
	}
}

VOID expect_handle::FakeRtlpUnwindEx(IN PVOID TargetFrame OPTIONAL,IN PVOID TargetIp OPTIONAL,IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,IN PVOID ReturnValue,IN PCONTEXT OriginalContext,IN PUNWIND_HISTORY_TABLE HistoryTable OPTIONAL,sim_process params_process)
{

	ULONG64 ControlPc;
	PCONTEXT CurrentContext;
	DISPATCHER_CONTEXT DispatcherContext;
	EXCEPTION_DISPOSITION Disposition;
	ULONG64 EstablisherFrame;
	ULONG ExceptionFlags;
	EXCEPTION_RECORD ExceptionRecord1;
	PEXCEPTION_ROUTINE ExceptionRoutine;
	PRUNTIME_FUNCTION FunctionEntry;
	PVOID HandlerData;
	ULONG64 HighLimit;
	ULONG64 ImageBase;
	CONTEXT LocalContext;
	ULONG64 LowLimit;
	PCONTEXT PreviousContext;
	ULONG ScopeIndex;
	PCONTEXT TempContext;

	uint64_t ValueFromAddress;
	//
	// Get current stack limits, capture the current context, virtually
	// unwind to the caller of this routine, get the initial PC value, and
	// set the unwind target address.
	//

	CurrentContext = OriginalContext;
	PreviousContext = &LocalContext;
	get_stack_limit(&LowLimit, &HighLimit, params_process);
	capture_context(CurrentContext, params_process);

	CurrentContext->Rip = (ULONG64)TargetIp;
	CurrentContext->Rsp = (ULONG64)TargetFrame;
	//
	// If a history table is specified, then set to search history table.
	//

	if (HistoryTable) {
		HistoryTable->Search = UNWIND_HISTORY_TABLE_GLOBAL;
	}

	//
	// If an exception record is not specified, then build a local exception
	// record for use in calling exception handlers during the unwind operation.
	//

	if (!ExceptionRecord) {
		ExceptionRecord = &ExceptionRecord1;
		ExceptionRecord1.ExceptionCode = STATUS_UNWIND;
		ExceptionRecord1.ExceptionRecord = NULL;
		ExceptionRecord1.ExceptionAddress = (PVOID)CurrentContext->Rip;
		ExceptionRecord1.NumberParameters = 0;
	}

	//
	// If the target frame of the unwind is specified, then a normal unwind
	// is being performed. Otherwise, an exit unwind is being performed.
	//

	ExceptionFlags = EXCEPTION_UNWINDING;
	if (!TargetFrame) {
		ExceptionFlags |= EXCEPTION_EXIT_UNWIND;
	}

	//
	// Scan backward through the call frame hierarchy and call exception
	// handlers until the target frame of the unwind is reached.
	//

	do {

		//
		// Lookup the function table entry using the point at which control
		// left the procedure.
		//

		ControlPc = CurrentContext->Rip;
		FunctionEntry = lookup_runtime_function_table(ControlPc, params_process);

		//
		// If there is a function table entry for the routine, then virtually
		// unwind to the caller of the routine to obtain the virtual frame
		// pointer of the establisher, but don't update the context record.
		//

		if (FunctionEntry != NULL) {
			copy_context(PreviousContext, CurrentContext);
			ExceptionRoutine = FakeRtlVirtualUnwind(UNW_FLAG_UHANDLER,
				ImageBase,
				ControlPc,
				FunctionEntry,
				PreviousContext,
				&HandlerData,
				&EstablisherFrame,
				NULL,
				params_process);

			//
			// If the establisher frame pointer is not within the specified
			// stack limits, the establisher frame pointer is unaligned, or
			// the target frame is below the establisher frame and an exit
			// unwind is not being performed, then raise a bad stack status.
			// Otherwise, check to determine if the current routine has an
			// exception handler.
			//

			if ((is_frame_in_bound(EstablisherFrame, &LowLimit,&HighLimit) == FALSE) ||
				(!TargetFrame &&
				((ULONG64)TargetFrame < EstablisherFrame))) {

				process_exception(STATUS_BAD_STACK, params_process);

			}
			else if (ExceptionRoutine != NULL) {

				//
				// The frame has a exception handler.
				//
				// A linkage routine written in assembler is used to actually
				// call the actual exception handler. This is required by the
				// exception handler that is associated with the linkage
				// routine so it can have access to two sets of dispatcher
				// context when it is called.
				//
				// Call the language specific handler.
				//

				DispatcherContext.TargetIp = (ULONG64)TargetIp;
				ScopeIndex = 0;
				do {

					//
					// If the establisher frame is the target of the unwind
					// operation, then set the target unwind flag.
					//

					if ((ULONG64)TargetFrame == EstablisherFrame) {
						ExceptionFlags |= EXCEPTION_TARGET_UNWIND;
					}

					//ExceptionRecord->ExceptionFlags = ExceptionFlags;
					uc_mem_write(g_global->uc_engine, (uint64_t)ExceptionRecord + offsetof(EXCEPTION_RECORD, ExceptionFlags), &ExceptionFlags, sizeof(ExceptionFlags));

					//
					// Set the specified return value and target IP in case
					// the exception handler directly continues execution.
					//

					CurrentContext->Rax = (ULONG64)ReturnValue;

					//
					// Set the dispatcher context and call the termination
					// handler.
					//

					DispatcherContext.ControlPc = ControlPc;
					DispatcherContext.ImageBase = ImageBase;
					DispatcherContext.FunctionEntry = FunctionEntry;
					DispatcherContext.EstablisherFrame = EstablisherFrame;
					DispatcherContext.ContextRecord = CurrentContext;
					DispatcherContext.LanguageHandler = ExceptionRoutine;
					DispatcherContext.HandlerData = HandlerData;
					DispatcherContext.HistoryTable = HistoryTable;
					DispatcherContext.ScopeIndex = ScopeIndex;
					Disposition = FakeRtlpExecuteHandlerForException(ExceptionRecord,
						(PVOID)EstablisherFrame,
						CurrentContext,
						&DispatcherContext,
						params_process);

					//
					// Clear target unwind and collided unwind flags.
					//

					ExceptionFlags &=
						~(EXCEPTION_COLLIDED_UNWIND | EXCEPTION_TARGET_UNWIND);

					//
					// Case on the handler disposition.
					//

					switch (Disposition) {

						//
						// The disposition is to continue the search.
						//
						// If the target frame has not been reached, then
						// swap context pointers.
						//

					case ExceptionContinueSearch:
						if (EstablisherFrame != (ULONG64)TargetFrame) {
							TempContext = CurrentContext;
							CurrentContext = PreviousContext;
							PreviousContext = TempContext;
						}

						break;

						//
						// The disposition is collided unwind.
						//
						// Copy the context of the previous unwind and
						// virtually unwind to the caller of the establisher,
						// then set the target of the current unwind to the
						// dispatcher context of the previous unwind, and
						// reexecute the exception handler from the collided
						// frame with the collided unwind flag set in the
						// exception record.
						//

					case ExceptionCollidedUnwind:
						ControlPc = DispatcherContext.ControlPc;
						ImageBase = DispatcherContext.ImageBase;
						FunctionEntry = DispatcherContext.FunctionEntry;
						copy_context(OriginalContext, DispatcherContext.ContextRecord);

						CurrentContext = OriginalContext;
						PreviousContext = &LocalContext;
						copy_context(PreviousContext, CurrentContext);
						FakeRtlVirtualUnwind(UNW_FLAG_NHANDLER,
							ImageBase,
							ControlPc,
							FunctionEntry,
							PreviousContext,
							&HandlerData,
							&EstablisherFrame,
							NULL,
							params_process);

						EstablisherFrame = DispatcherContext.EstablisherFrame;
						ExceptionRoutine = DispatcherContext.LanguageHandler;
						HandlerData = DispatcherContext.HandlerData;
						HistoryTable = DispatcherContext.HistoryTable;
						ScopeIndex = DispatcherContext.ScopeIndex;
						ExceptionFlags |= EXCEPTION_COLLIDED_UNWIND;
						break;

						//
						// All other disposition values are invalid.
						//
						// Raise invalid disposition exception.
						//

					default:
						process_exception(STATUS_INVALID_DISPOSITION,params_process);
					}

				} while ((ExceptionFlags & EXCEPTION_COLLIDED_UNWIND) != 0);

			}
			else {

				//
				// If the target frame has not been reached, then swap
				// context pointers.
				//

				if (EstablisherFrame != (ULONG64)TargetFrame) {
					TempContext = CurrentContext;
					CurrentContext = PreviousContext;
					PreviousContext = TempContext;
				}
			}

		}
		else {

			//
			// Set the point where control left the current function by
			// obtaining the return address from the top of the stack.
			//

			uc_mem_read(g_global->uc_engine, (uint64_t)CurrentContext->Rsp, &ValueFromAddress, sizeof(ValueFromAddress));

			CurrentContext->Rip = ValueFromAddress;
			CurrentContext->Rsp += 8;
		}

	} while ((is_frame_in_bound(EstablisherFrame, &LowLimit, &HighLimit) == TRUE) &&(EstablisherFrame != (ULONG64)TargetFrame));

	//
	// If the establisher stack pointer is equal to the target frame pointer,
	// then continue execution. Otherwise, an exit unwind was performed or the
	// target of the unwind did not exist and the debugger and subsystem are
	// given a second chance to handle the unwind.
	//

	if (EstablisherFrame == (ULONG64)TargetFrame) {
		CurrentContext->Rax = (ULONG64)ReturnValue;

		ULONG ExceptionCode;
		uc_mem_read(g_global->uc_engine, (uint64_t)ExceptionRecord + offsetof(EXCEPTION_RECORD, ExceptionCode), &ExceptionCode, sizeof(ExceptionCode));

		if (ExceptionCode != STATUS_UNWIND_CONSOLIDATE) {
			CurrentContext->Rip = (ULONG64)TargetIp;
		}

		set_context(CurrentContext, params_process);
	}
	else {

		//
		// If the old control PC is the same as the new control PC, then
		// no progress is being made and the function tables are most likely
		// malformed. Otherwise, give the debugger and subsystem a second
		// chance to handle the exception.

		if (ControlPc == CurrentContext->Rip) {
			process_exception(STATUS_BAD_FUNCTION_TABLE, params_process);

		}
		else {
			__debugbreak();
		}
	}
}

EXCEPTION_DISPOSITION expect_handle::C_specific_handler(sim_process params_process)
{
	ULONG_PTR ControlPc = 0;
	PEXCEPTION_FILTER ExceptionFilter = NULL;
	EXCEPTION_POINTERS ExceptionPointers = { 0 };
	ULONG_PTR ImageBase = 0;
	ULONG_PTR Handler = 0;
	ULONG Index = 0;
	PSCOPE_TABLE ScopeTable = NULL;
	ULONG TargetIndex = 0;
	ULONG_PTR TargetPc = 0;
	PTERMINATION_HANDLER TerminationHandler = NULL;
	LONG Value = 0;

	uint64_t ExceptionRecordBase;
	uc_reg_read(g_global->uc_engine, UC_X86_REG_RCX, &ExceptionRecordBase);
	EXCEPTION_RECORD ExceptionRecord;
	uc_mem_read(g_global->uc_engine, ExceptionRecordBase, &ExceptionRecord, sizeof(EXCEPTION_RECORD));

	uint64_t EstablisherFrame;
	uc_reg_read(g_global->uc_engine, UC_X86_REG_RDX, &EstablisherFrame);

	uint64_t ContextRecordBase;
	uc_reg_read(g_global->uc_engine, UC_X86_REG_R8, &ContextRecordBase);
	CONTEXT ContextRecord;
	uc_mem_read(g_global->uc_engine, ContextRecordBase, &ContextRecord, sizeof(CONTEXT));

	uint64_t DispatcherContextBase;
	uc_reg_read(g_global->uc_engine, UC_X86_REG_R9, &DispatcherContextBase);
	DISPATCHER_CONTEXT DispatcherContext;
	uc_mem_read(g_global->uc_engine, DispatcherContextBase, &DispatcherContext, sizeof(DISPATCHER_CONTEXT));

	ImageBase = DispatcherContext.ImageBase;
	ControlPc = DispatcherContext.ControlPc - ImageBase;
	ScopeTable = (PSCOPE_TABLE)(DispatcherContext.HandlerData);

	typedef struct {
		DWORD BeginAddress;
		DWORD EndAddress;
		DWORD HandlerAddress;
		DWORD JumpTarget;
	} ScopeRecord_t;

	crt_buffer_t ScopeTableCell(offsetof(SCOPE_TABLE, ScopeRecord));
	uc_mem_read(g_global->uc_engine, (uint64_t)ScopeTable, ScopeTableCell.GetBuffer(), ScopeTableCell.GetLength());
	PSCOPE_TABLE ScopeTableCellPtr = (PSCOPE_TABLE)ScopeTableCell.GetBuffer();
	ScopeTableCell.GetSpace(offsetof(SCOPE_TABLE, ScopeRecord) + ScopeTableCellPtr->Count * sizeof(ScopeRecord_t));
	uc_mem_read(g_global->uc_engine, (uint64_t)ScopeTable, ScopeTableCell.GetBuffer(), ScopeTableCell.GetLength());
	ScopeTableCellPtr = (PSCOPE_TABLE)ScopeTableCell.GetBuffer();

	if (IS_DISPATCHING(ExceptionRecord.ExceptionFlags)) {
		ExceptionPointers.ExceptionRecord = (PEXCEPTION_RECORD)ExceptionRecordBase;
		ExceptionPointers.ContextRecord = (PCONTEXT)ContextRecordBase;

		for (Index = DispatcherContext.ScopeIndex;
			Index < ScopeTableCellPtr->Count;
			Index += 1) {
			if ((ControlPc >= ScopeTableCellPtr->ScopeRecord[Index].BeginAddress) &&
				(ControlPc < ScopeTableCellPtr->ScopeRecord[Index].EndAddress) &&
				(ScopeTableCellPtr->ScopeRecord[Index].JumpTarget != 0)) {
				if (ScopeTableCellPtr->ScopeRecord[Index].HandlerAddress == 1) {
					Value = EXCEPTION_EXECUTE_HANDLER;
				}
				else {
					ExceptionFilter = (PEXCEPTION_FILTER)
						(ScopeTableCellPtr->ScopeRecord[Index].HandlerAddress + ImageBase);

					//Value = ExceptionFilter(&ExceptionPointers, (PVOID)EstablisherFrame);
					auto ExceptionPointersBase = api_emu::StackAlloc(g_global->uc_engine, sizeof(ExceptionPointers));
					uc_mem_write(g_global->uc_engine, ExceptionPointersBase, &ExceptionPointers, sizeof(ExceptionPointers));

					uc_reg_write(g_global->uc_engine, UC_X86_REG_RCX, &ExceptionPointersBase);
					uc_reg_write(g_global->uc_engine, UC_X86_REG_RDX, &EstablisherFrame);

					uint64_t retAddr = api_emu::StackAlloc(g_global->uc_engine, sizeof(params_process.m_image_end));
					uc_mem_write(g_global->uc_engine, retAddr, &params_process.m_image_end, sizeof(params_process.m_image_end));

					auto err = uc_emu_start(g_global->uc_engine, (uint64_t)ExceptionFilter, params_process.m_image_end, 0, 0);

					api_emu::StackFree(g_global->uc_engine, sizeof(ExceptionPointers));

					uc_reg_read(g_global->uc_engine, UC_X86_REG_RAX, &Value);
				}

				if (Value < 0) {
					return ExceptionContinueExecution;
				}
				else if (Value > 0) {

					FakeRtlpUnwindEx(
						(PVOID)EstablisherFrame,
						(PVOID)(ScopeTableCellPtr->ScopeRecord[Index].JumpTarget + ImageBase),
						(PEXCEPTION_RECORD)ExceptionRecordBase,
						(PVOID)((ULONG_PTR)ExceptionRecord.ExceptionCode),
						(PCONTEXT)DispatcherContext.ContextRecord,
						DispatcherContext.HistoryTable,
						params_process);

					params_process.m_ExecuteExceptionHandler = 2;

					return ExceptionContinueExecution;
				}
			}
		}
	}
	else {

		TargetPc = DispatcherContext.TargetIp - ImageBase;

		for (Index = DispatcherContext.ScopeIndex;
			Index < ScopeTableCellPtr->Count;
			Index += 1) {
			if ((ControlPc >= ScopeTableCellPtr->ScopeRecord[Index].BeginAddress) &&
				(ControlPc < ScopeTableCellPtr->ScopeRecord[Index].EndAddress)) {
				if (IS_TARGET_UNWIND(ExceptionRecord.ExceptionFlags)) {
					for (TargetIndex = 0;
						TargetIndex < ScopeTableCellPtr->Count;
						TargetIndex += 1) {
						if ((TargetPc >= ScopeTableCellPtr->ScopeRecord[TargetIndex].BeginAddress) &&
							(TargetPc < ScopeTableCellPtr->ScopeRecord[TargetIndex].EndAddress) &&
							(ScopeTableCellPtr->ScopeRecord[TargetIndex].JumpTarget ==
								ScopeTableCellPtr->ScopeRecord[Index].JumpTarget) &&
								(ScopeTableCellPtr->ScopeRecord[TargetIndex].HandlerAddress ==
									ScopeTableCellPtr->ScopeRecord[Index].HandlerAddress)) {
							break;
						}
					}

					if (TargetIndex != ScopeTableCellPtr->Count) {
						break;
					}
				}

				if (ScopeTableCellPtr->ScopeRecord[Index].JumpTarget != 0) {
					if ((TargetPc == ScopeTableCellPtr->ScopeRecord[Index].JumpTarget) &&
						(IS_TARGET_UNWIND(ExceptionRecord.ExceptionFlags))) {
						break;
					}
				}
				else {
					DispatcherContext.ScopeIndex = Index + 1;

					TerminationHandler = (PTERMINATION_HANDLER)
						(ScopeTable->ScopeRecord[Index].HandlerAddress + ImageBase);


					//TerminationHandler(TRUE, (PVOID)EstablisherFrame);
				}
			}
		}
	}

	return ExceptionContinueSearch;
}
EXCEPTION_DISPOSITION expect_handle::FakeRtlpExecuteHandlerForException(_Inout_ struct _EXCEPTION_RECORD* ExceptionRecord,_In_ PVOID EstablisherFrame,_Inout_ struct _CONTEXT* ContextRecord,_In_ PDISPATCHER_CONTEXT DispatcherContext, sim_process params_process)
{
	EXCEPTION_DISPOSITION dispo = ExceptionContinueExecution;
	auto ExceptionRecordBase = api_emu::StackAlloc(g_global->uc_engine, sizeof(EXCEPTION_RECORD));
	auto ContextRecordBase = api_emu::StackAlloc(g_global->uc_engine, sizeof(CONTEXT));
	auto DispatcherContextBase = api_emu::StackAlloc(g_global->uc_engine, sizeof(DISPATCHER_CONTEXT));

	uc_mem_write(g_global->uc_engine, ExceptionRecordBase, ExceptionRecord, sizeof(EXCEPTION_RECORD));
	uc_mem_write(g_global->uc_engine, ContextRecordBase, ContextRecord, sizeof(CONTEXT));
	uc_mem_write(g_global->uc_engine, DispatcherContextBase, DispatcherContext, sizeof(DISPATCHER_CONTEXT));

	uc_reg_write(g_global->uc_engine, UC_X86_REG_RCX, &ExceptionRecordBase);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_RDX, &EstablisherFrame);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_R8, &ContextRecordBase);
	uc_reg_write(g_global->uc_engine, UC_X86_REG_R9, &DispatcherContextBase);

	uint64_t retAddr = api_emu::StackAlloc(g_global->uc_engine, sizeof(params_process.m_image_end));
	uc_mem_write(g_global->uc_engine, retAddr, &params_process.m_image_end, sizeof(params_process.m_image_end));
	api_emu::StackAlloc(g_global->uc_engine, 7 * sizeof(ULONG64));
	//push m_ImageEnd
	//sub rsp, 7 * dq

	auto err = uc_emu_start(g_global->uc_engine, (uint64_t)DispatcherContext->LanguageHandler, params_process.m_image_end, 0, 0);

	
	if (params_process.m_ExecuteExceptionHandler == 1)
	{
		params_process.m_ExecuteExceptionHandler = 0;
		return C_specific_handler(params_process);
	}
	
	//add rsp, 7 * dq
	api_emu::StackFree(g_global->uc_engine, 7 * sizeof(ULONG64));

	uc_mem_read(g_global->uc_engine, ExceptionRecordBase, ExceptionRecord, sizeof(EXCEPTION_RECORD));
	uc_mem_read(g_global->uc_engine, ContextRecordBase, ContextRecord, sizeof(CONTEXT));
	uc_mem_read(g_global->uc_engine, DispatcherContextBase, DispatcherContext, sizeof(DISPATCHER_CONTEXT));

	api_emu::StackFree(g_global->uc_engine, sizeof(EXCEPTION_RECORD));
	api_emu::StackFree(g_global->uc_engine, sizeof(CONTEXT));
	api_emu::StackFree(g_global->uc_engine, sizeof(DISPATCHER_CONTEXT));

	return dispo;
}
/*
	这边模拟windows异常分发
*/
bool expect_handle::dispatch_exception(PEXCEPTION_RECORD params_exception,PCONTEXT params_context, sim_process params_process) {
	uint64_t m_low_limit, m_hight_limit, m_exception_address, m_exception_flag, m_nested_frame;
	CONTEXT context_copyed;
	PRUNTIME_FUNCTION FunctionEntry;
	PEXCEPTION_ROUTINE ExceptionRoutine;
	PVOID HandlerData;
	ULONG64 EstablisherFrame;
	BOOLEAN Repeat;
	ULONG ScopeIndex;
	DISPATCHER_CONTEXT DispatcherContext;
	BOOLEAN Completion = FALSE;
	EXCEPTION_DISPOSITION Disposition;
	/*
		1.得到栈大小,拷贝上下文,得到异常代码
	*/
	get_stack_limit(&m_low_limit, &m_hight_limit, params_process);
	copy_context(&context_copyed, params_context);
	m_exception_address = (uint64_t)params_exception->ExceptionAddress;
	m_exception_flag = params_exception->ExceptionFlags & EXCEPTION_NONCONTINUABLE;
	m_nested_frame = 0;
	/*
		2. 初始化unwind history表,我们这边不做,所以忽略...
	*/

	//初始化unwind history表

	/*
		3. 在栈上找异常处理程序
	*/
	do
	{
		FunctionEntry = lookup_runtime_function_table(m_exception_address, params_process);
		if (FunctionEntry != NULL) {
			/*
				找到了最近的runtime_function 检查里面有没有对应的异常处理函数
				这里我们模拟windows的RtlpVirtualUnwind
			*/
			ExceptionRoutine = FakeRtlVirtualUnwind(UNW_FLAG_EHANDLER, params_process.m_image_base, m_exception_address, FunctionEntry,&context_copyed, &HandlerData,&EstablisherFrame,NULL,params_process);
			if (is_frame_in_bound(EstablisherFrame , &m_low_limit, &m_hight_limit) == FALSE) {
				m_exception_flag |= EXCEPTION_STACK_INVALID;
				break;
			}
			else if (ExceptionRoutine != NULL) {
				//
				// The frame has an exception handler.
				//
				// A linkage routine written in assembler is used to actually
				// call the actual exception handler. This is required by the
				// exception handler that is associated with the linkage
				// routine so it can have access to two sets of dispatcher
				// context when it is called.
				//
				// Call the language specific handler.
				//

				ScopeIndex = 0;
				do {

					//
					// Log the exception if exception logging is enabled.
					//

					params_exception->ExceptionFlags = m_exception_flag;


					//
					// Clear repeat, set the dispatcher context, and call the
					// exception handler.
					//

					Repeat = FALSE;
					DispatcherContext.ControlPc = m_exception_address;
					DispatcherContext.ImageBase = params_process.m_image_base;
					DispatcherContext.FunctionEntry = FunctionEntry;
					DispatcherContext.EstablisherFrame = EstablisherFrame;
					DispatcherContext.ContextRecord = &context_copyed;
					DispatcherContext.LanguageHandler = ExceptionRoutine;
					DispatcherContext.HandlerData = HandlerData;
					//DispatcherContext.HistoryTable = HistoryTable;
					DispatcherContext.ScopeIndex = ScopeIndex;

					//
					Disposition = FakeRtlpExecuteHandlerForException(params_exception, (PVOID)EstablisherFrame, params_context, &DispatcherContext, params_process);

					//
					// Propagate noncontinuable exception flag.
					//

					m_exception_flag |= (params_exception->ExceptionFlags & EXCEPTION_NONCONTINUABLE);

					if (params_process.m_ExecuteExceptionHandler == 2)
					{
						params_process.m_ExecuteExceptionHandler = 0;
						Completion = TRUE;
						goto DispatchExit;
					}

					//
					// If the current scan is within a nested context and the
					// frame just examined is the end of the nested region,
					// then clear the nested context frame and the nested
					// exception flag in the exception flags.
					//

					if (m_nested_frame == EstablisherFrame) {
						m_exception_flag &= (~EXCEPTION_NESTED_CALL);
						m_nested_frame = 0;
					}

					//
					// Case on the handler disposition.
					//

					switch (Disposition) {

						//
						// The disposition is to continue execution.
						//
						// If the exception is not continuable, then raise
						// the exception STATUS_NONCONTINUABLE_EXCEPTION.
						// Otherwise return exception handled.
						//

					case ExceptionContinueExecution:
						if ((m_exception_flag & EXCEPTION_NONCONTINUABLE) != 0) {
							process_exception(STATUS_NONCONTINUABLE_EXCEPTION, params_process);

						}
						else {
							Completion = TRUE;
							goto DispatchExit;
						}

						//
						// The disposition is to continue the search.
						//
						// Get next frame address and continue the search.
						//

					case ExceptionContinueSearch:
						break;

						//
						// The disposition is nested exception.
						//
						// Set the nested context frame to the establisher frame
						// address and set the nested exception flag in the
						// exception flags.
						//

					case ExceptionNestedException:
						m_exception_flag |= EXCEPTION_NESTED_CALL;
						if (DispatcherContext.EstablisherFrame > m_nested_frame) {
							m_nested_frame = DispatcherContext.EstablisherFrame;
						}

						break;

						//
						// The dispostion is collided unwind.
						//
						// A collided unwind occurs when an exception dispatch
						// encounters a previous call to an unwind handler. In
						// this case the previous unwound frames must be skipped.
						//

					case ExceptionCollidedUnwind:
						m_exception_address = DispatcherContext.ControlPc;
						//ImageBase = DispatcherContext.ImageBase;
						FunctionEntry = DispatcherContext.FunctionEntry;
						EstablisherFrame = DispatcherContext.EstablisherFrame;
						copy_context(&context_copyed,DispatcherContext.ContextRecord);
						context_copyed.Rip = m_exception_address;
						ExceptionRoutine = DispatcherContext.LanguageHandler;
						HandlerData = DispatcherContext.HandlerData;
						//HistoryTable = DispatcherContext.HistoryTable;
						ScopeIndex = DispatcherContext.ScopeIndex;
						Repeat = TRUE;
						break;

						//
						// All other disposition values are invalid.
						//
						// Raise invalid disposition exception.
						//

					default:
						process_exception(STATUS_INVALID_DISPOSITION, params_process);
					}

				} while (Repeat != FALSE);
			}
		}

	} while (is_frame_in_bound((ULONG64)context_copyed.Rsp, &m_low_limit, &m_hight_limit) == true);

	//
	// Set final exception flags and return exception not handled.
	//

	params_exception->ExceptionFlags = m_exception_flag;

	//
	// Call vectored continue handlers.
	//

DispatchExit:

	return Completion;
}
void expect_handle::process_exception(NTSTATUS params_last_exception, sim_process params_process)
{
	CONTEXT context;
	EXCEPTION_RECORD exception;
	capture_context(&context, params_process);

	exception.ExceptionCode = params_last_exception;
	exception.ExceptionRecord = NULL;
	exception.NumberParameters = 0;
	exception.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
	exception.ExceptionAddress = (PVOID)context.Rip;

	dispatch_exception(&exception, &context, params_process);
}
