#pragma once
#include "head.h"
typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING* PUNICODE_STRING;
typedef const UNICODE_STRING* PCUNICODE_STRING;

enum class Msr : unsigned int {
	kIa32ApicBase = 0x01B,

	kIa32FeatureControl = 0x03A,

	kIa32SysenterCs = 0x174,
	kIa32SysenterEsp = 0x175,
	kIa32SysenterEip = 0x176,

	kIa32Debugctl = 0x1D9,

	kIa32MtrrCap = 0xFE,
	kIa32MtrrDefType = 0x2FF,
	kIa32MtrrPhysBaseN = 0x200,
	kIa32MtrrPhysMaskN = 0x201,
	kIa32MtrrFix64k00000 = 0x250,
	kIa32MtrrFix16k80000 = 0x258,
	kIa32MtrrFix16kA0000 = 0x259,
	kIa32MtrrFix4kC0000 = 0x268,
	kIa32MtrrFix4kC8000 = 0x269,
	kIa32MtrrFix4kD0000 = 0x26A,
	kIa32MtrrFix4kD8000 = 0x26B,
	kIa32MtrrFix4kE0000 = 0x26C,
	kIa32MtrrFix4kE8000 = 0x26D,
	kIa32MtrrFix4kF0000 = 0x26E,
	kIa32MtrrFix4kF8000 = 0x26F,

	kIa32VmxBasic = 0x480,
	kIa32VmxPinbasedCtls = 0x481,
	kIa32VmxProcBasedCtls = 0x482,
	kIa32VmxExitCtls = 0x483,
	kIa32VmxEntryCtls = 0x484,
	kIa32VmxMisc = 0x485,
	kIa32VmxCr0Fixed0 = 0x486,
	kIa32VmxCr0Fixed1 = 0x487,
	kIa32VmxCr4Fixed0 = 0x488,
	kIa32VmxCr4Fixed1 = 0x489,
	kIa32VmxVmcsEnum = 0x48A,
	kIa32VmxProcBasedCtls2 = 0x48B,
	kIa32VmxEptVpidCap = 0x48C,
	kIa32VmxTruePinbasedCtls = 0x48D,
	kIa32VmxTrueProcBasedCtls = 0x48E,
	kIa32VmxTrueExitCtls = 0x48F,
	kIa32VmxTrueEntryCtls = 0x490,
	kIa32VmxVmfunc = 0x491,

	kIa32Efer = 0xC0000080,
	kIa32Star = 0xC0000081,
	kIa32Lstar = 0xC0000082,

	kIa32Fmask = 0xC0000084,

	kIa32FsBase = 0xC0000100,
	kIa32GsBase = 0xC0000101,
	kIa32KernelGsBase = 0xC0000102,
	kIa32TscAux = 0xC0000103,
};
typedef struct _PEB_LDR_DATA {
	BYTE Reserved1[8];
	PVOID Reserved2[3];
	LIST_ENTRY InMemoryOrderModuleList;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _LDR_DATA_TABLE_ENTRY {
	PVOID Reserved1[2];
	LIST_ENTRY InMemoryOrderLinks;
	PVOID Reserved2[2];
	PVOID DllBase;
	PVOID Reserved3[2];
	UNICODE_STRING FullDllName;
	BYTE Reserved4[8];
	PVOID Reserved5[3];
#pragma warning(push)
#pragma warning(disable: 4201) // we'll always use the Microsoft compiler
	union {
		ULONG CheckSum;
		PVOID Reserved6;
	} DUMMYUNIONNAME;
#pragma warning(pop)
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
	BYTE Reserved1[16];
	PVOID Reserved2[10];
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef
VOID
(NTAPI* PPS_POST_PROCESS_INIT_ROUTINE) (
	VOID
	);

typedef struct _PEB {
	BYTE Reserved1[2];
	BYTE BeingDebugged;
	BYTE Reserved2[1];
	PVOID Reserved3[2];
	PPEB_LDR_DATA Ldr;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID Reserved4[3];
	PVOID AtlThunkSListPtr;
	PVOID Reserved5;
	ULONG Reserved6;
	PVOID Reserved7;
	ULONG Reserved8;
	ULONG AtlThunkSListPtr32;
	PVOID Reserved9[45];
	BYTE Reserved10[96];
	PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
	BYTE Reserved11[128];
	PVOID Reserved12[1];
	ULONG SessionId;
} PEB, * PPEB;
/*
	x64的teb_64 32位的没做
*/
struct _ACTIVATION_CONTEXT_STACK
{
	struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME* ActiveFrame;                //0x0
	struct _LIST_ENTRY FrameListCache;                                      //0x8
	ULONG Flags;                                                            //0x18
	ULONG NextCookieSequenceNumber;                                         //0x1c
	ULONG StackId;                                                          //0x20
};
struct _GDI_TEB_BATCH
{
	ULONG Offset : 31;                                                        //0x0
	ULONG HasRenderingCommand : 1;                                            //0x0
	ULONGLONG HDC;                                                          //0x8
	ULONG Buffer[310];                                                      //0x10
};
struct _CLIENT_ID
{
	DWORD64 UniqueProcess;                                                    //0x0
	DWORD64 UniqueThread;                                                     //0x8
};
static_assert(sizeof(_CLIENT_ID) == 0x10, "_CLIENT_ID Size check");

static_assert(sizeof(_NT_TIB) == 0x38, "_NT_TIB Size check");
typedef struct X64TEB {
	struct _NT_TIB NtTib;                                                   //0x0
	VOID* EnvironmentPointer;                                               //0x38
	struct _CLIENT_ID ClientId;                                             //0x40
	VOID* ActiveRpcHandle;                                                  //0x50
	VOID* ThreadLocalStoragePointer;                                        //0x58
	struct _PEB* ProcessEnvironmentBlock;                                   //0x60
	ULONG LastErrorValue;                                                   //0x68
	ULONG CountOfOwnedCriticalSections;                                     //0x6c
	VOID* CsrClientThread;                                                  //0x70
	VOID* Win32ThreadInfo;                                                  //0x78
	ULONG User32Reserved[26];                                               //0x80
	ULONG UserReserved[5];                                                  //0xe8
	VOID* WOW32Reserved;                                                    //0x100
	ULONG CurrentLocale;                                                    //0x108
	ULONG FpSoftwareStatusRegister;                                         //0x10c
	VOID* ReservedForDebuggerInstrumentation[16];                           //0x110
	VOID* SystemReserved1[30];                                              //0x190
	CHAR PlaceholderCompatibilityMode;                                      //0x280
	UCHAR PlaceholderHydrationAlwaysExplicit;                               //0x281
	CHAR PlaceholderReserved[10];                                           //0x282
	ULONG ProxiedProcessId;                                                 //0x28c
	struct _ACTIVATION_CONTEXT_STACK _ActivationStack;                      //0x290
	UCHAR WorkingOnBehalfTicket[8];                                         //0x2b8
	LONG ExceptionCode;                                                     //0x2c0
	UCHAR Padding0[4];                                                      //0x2c4
	struct _ACTIVATION_CONTEXT_STACK* ActivationContextStackPointer;        //0x2c8
	ULONGLONG InstrumentationCallbackSp;                                    //0x2d0
	ULONGLONG InstrumentationCallbackPreviousPc;                            //0x2d8
	ULONGLONG InstrumentationCallbackPreviousSp;                            //0x2e0
	ULONG TxFsContext;                                                      //0x2e8
	UCHAR InstrumentationCallbackDisabled;                                  //0x2ec
	UCHAR UnalignedLoadStoreExceptions;                                     //0x2ed
	UCHAR Padding1[2];                                                      //0x2ee
	struct _GDI_TEB_BATCH GdiTebBatch;                                      //0x2f0
	struct _CLIENT_ID RealClientId;                                         //0x7d8
	VOID* GdiCachedProcessHandle;                                           //0x7e8
	ULONG GdiClientPID;                                                     //0x7f0
	ULONG GdiClientTID;                                                     //0x7f4
	VOID* GdiThreadLocalInfo;                                               //0x7f8
	ULONGLONG Win32ClientInfo[62];                                          //0x800
	VOID* glDispatchTable[233];                                             //0x9f0
	ULONGLONG glReserved1[29];                                              //0x1138
	VOID* glReserved2;                                                      //0x1220
	VOID* glSectionInfo;                                                    //0x1228
	VOID* glSection;                                                        //0x1230
	VOID* glTable;                                                          //0x1238
	VOID* glCurrentRC;                                                      //0x1240
	VOID* glContext;                                                        //0x1248
	ULONG LastStatusValue;                                                  //0x1250
	UCHAR Padding2[4];                                                      //0x1254
	struct _UNICODE_STRING StaticUnicodeString;                             //0x1258
	WCHAR StaticUnicodeBuffer[261];                                         //0x1268
	UCHAR Padding3[6];                                                      //0x1472
	VOID* DeallocationStack;                                                //0x1478
	VOID* TlsSlots[64];                                                     //0x1480
	struct _LIST_ENTRY TlsLinks;                                            //0x1680
	VOID* Vdm;                                                              //0x1690
	VOID* ReservedForNtRpc;                                                 //0x1698
	VOID* DbgSsReserved[2];                                                 //0x16a0
	ULONG HardErrorMode;                                                    //0x16b0
	UCHAR Padding4[4];                                                      //0x16b4
	VOID* Instrumentation[11];                                              //0x16b8
	struct _GUID ActivityId;                                                //0x1710
	VOID* SubProcessTag;                                                    //0x1720
	VOID* PerflibData;                                                      //0x1728
	VOID* EtwTraceData;                                                     //0x1730
	VOID* WinSockData;                                                      //0x1738
	ULONG GdiBatchCount;                                                    //0x1740
	union
	{
		struct _PROCESSOR_NUMBER CurrentIdealProcessor;                     //0x1744
		ULONG IdealProcessorValue;                                          //0x1744
		struct
		{
			UCHAR ReservedPad0;                                             //0x1744
			UCHAR ReservedPad1;                                             //0x1745
			UCHAR ReservedPad2;                                             //0x1746
			UCHAR IdealProcessor;                                           //0x1747
		};
	};
	ULONG GuaranteedStackBytes;                                             //0x1748
	UCHAR Padding5[4];                                                      //0x174c
	VOID* ReservedForPerf;                                                  //0x1750
	VOID* ReservedForOle;                                                   //0x1758
	ULONG WaitingOnLoaderLock;                                              //0x1760
	UCHAR Padding6[4];                                                      //0x1764
	VOID* SavedPriorityState;                                               //0x1768
	ULONGLONG ReservedForCodeCoverage;                                      //0x1770
	VOID* ThreadPoolData;                                                   //0x1778
	VOID** TlsExpansionSlots;                                               //0x1780
	VOID* DeallocationBStore;                                               //0x1788
	VOID* BStoreLimit;                                                      //0x1790
	ULONG MuiGeneration;                                                    //0x1798
	ULONG IsImpersonating;                                                  //0x179c
	VOID* NlsCache;                                                         //0x17a0
	VOID* pShimData;                                                        //0x17a8
	ULONG HeapData;                                                         //0x17b0
	UCHAR Padding7[4];                                                      //0x17b4
	VOID* CurrentTransactionHandle;                                         //0x17b8
	struct _TEB_ACTIVE_FRAME* ActiveFrame;                                  //0x17c0
	VOID* FlsData;                                                          //0x17c8
	VOID* PreferredLanguages;                                               //0x17d0
	VOID* UserPrefLanguages;                                                //0x17d8
	VOID* MergedPrefLanguages;                                              //0x17e0
	ULONG MuiImpersonation;                                                 //0x17e8
	union
	{
		volatile USHORT CrossTebFlags;                                      //0x17ec
		USHORT SpareCrossTebBits : 16;                                        //0x17ec
	};
	union
	{
		USHORT SameTebFlags;                                                //0x17ee
		struct
		{
			USHORT SafeThunkCall : 1;                                         //0x17ee
			USHORT InDebugPrint : 1;                                          //0x17ee
			USHORT HasFiberData : 1;                                          //0x17ee
			USHORT SkipThreadAttach : 1;                                      //0x17ee
			USHORT WerInShipAssertCode : 1;                                   //0x17ee
			USHORT RanProcessInit : 1;                                        //0x17ee
			USHORT ClonedThread : 1;                                          //0x17ee
			USHORT SuppressDebugMsg : 1;                                      //0x17ee
			USHORT DisableUserStackWalk : 1;                                  //0x17ee
			USHORT RtlExceptionAttached : 1;                                  //0x17ee
			USHORT InitialThread : 1;                                         //0x17ee
			USHORT SessionAware : 1;                                          //0x17ee
			USHORT LoadOwner : 1;                                             //0x17ee
			USHORT LoaderWorker : 1;                                          //0x17ee
			USHORT SkipLoaderInit : 1;                                        //0x17ee
			USHORT SpareSameTebBits : 1;                                      //0x17ee
		};
	};
	VOID* TxnScopeEnterCallback;                                            //0x17f0
	VOID* TxnScopeExitCallback;                                             //0x17f8
	VOID* TxnScopeContext;                                                  //0x1800
	ULONG LockCount;                                                        //0x1808
	LONG WowTebOffset;                                                      //0x180c
	VOID* ResourceRetValue;                                                 //0x1810
	VOID* ReservedForWdf;                                                   //0x1818
	ULONGLONG ReservedForCrt;                                               //0x1820
	struct _GUID EffectiveContainerId;                                      //0x1828
};
static_assert(sizeof(X64TEB) == 0x1838, "TEB Size check");
struct struct_gs_base {
	char unk[0x30]; //0x0
	uint64_t teb; //0x30
};
/// See: Segment Descriptor
union SegmentDescriptor {
	ULONG64 all;
	struct {
		ULONG64 limit_low : 16;
		ULONG64 base_low : 16;
		ULONG64 base_mid : 8;
		ULONG64 type : 4;
		ULONG64 system : 1;
		ULONG64 dpl : 2;
		ULONG64 present : 1;
		ULONG64 limit_high : 4;
		ULONG64 avl : 1;
		ULONG64 l : 1;  //!< 64-bit code segment (IA-32e mode only)
		ULONG64 db : 1;
		ULONG64 gran : 1;
		ULONG64 base_high : 8;
	} fields;
};
/// @copydoc SegmentDescriptor
struct SegmentDesctiptorX64 {
	SegmentDescriptor descriptor;
	ULONG32 base_upper32;
	ULONG32 reserved;
};
//每个系统的KPCR结构都不一样,懒了
typedef struct _KPCR
{
	SegmentDesctiptorX64 gdt[8];
}KPCR;

#include <pshpack1.h>
struct Idtr {
	unsigned short limit;
	ULONG_PTR base;
};

struct Idtr32 {
	unsigned short limit;
	ULONG32 base;
};
static_assert(sizeof(Idtr32) == 6, "Size check");
using Gdtr = Idtr;
#if defined(_AMD64_)
static_assert(sizeof(Idtr) == 10, "Size check");
static_assert(sizeof(Gdtr) == 10, "Size check");
#else
static_assert(sizeof(Idtr) == 6, "Size check");
static_assert(sizeof(Gdtr) == 6, "Size check");
#endif

#include <pshpack1.h>
union SegmentSelector {
	unsigned short all;
	struct {
		unsigned short rpl : 2;  //!< Requested Privilege Level
		unsigned short ti : 1;   //!< Table Indicator
		unsigned short index : 13;
	} fields;
};
static_assert(sizeof(SegmentSelector) == 2, "Size check");
#include <poppack.h>

union FlagRegister {
	ULONG_PTR all;
	struct {
		ULONG_PTR cf : 1;          //!< [0] Carry flag
		ULONG_PTR reserved1 : 1;   //!< [1] Always 1
		ULONG_PTR pf : 1;          //!< [2] Parity flag
		ULONG_PTR reserved2 : 1;   //!< [3] Always 0
		ULONG_PTR af : 1;          //!< [4] Borrow flag
		ULONG_PTR reserved3 : 1;   //!< [5] Always 0
		ULONG_PTR zf : 1;          //!< [6] Zero flag
		ULONG_PTR sf : 1;          //!< [7] Sign flag
		ULONG_PTR tf : 1;          //!< [8] Trap flag
		ULONG_PTR intf : 1;        //!< [9] Interrupt flag
		ULONG_PTR df : 1;          //!< [10] Direction flag
		ULONG_PTR of : 1;          //!< [11] Overflow flag
		ULONG_PTR iopl : 2;        //!< [12:13] I/O privilege level
		ULONG_PTR nt : 1;          //!< [14] Nested task flag
		ULONG_PTR reserved4 : 1;   //!< [15] Always 0
		ULONG_PTR rf : 1;          //!< [16] Resume flag
		ULONG_PTR vm : 1;          //!< [17] Virtual 8086 mode
		ULONG_PTR ac : 1;          //!< [18] Alignment check
		ULONG_PTR vif : 1;         //!< [19] Virtual interrupt flag
		ULONG_PTR vip : 1;         //!< [20] Virtual interrupt pending
		ULONG_PTR id : 1;          //!< [21] Identification flag
		ULONG_PTR reserved5 : 10;  //!< [22:31] Always 0
	} fields;
};
struct moudle_export {
	char name[MAX_PATH];
	uint64_t function_address;
	void* function_callback;
};
struct moudle_import {
	char name[MAX_PATH];
	uint64_t function_address;
	void* function_callback;
};
struct moudle_section {
	char name[9];
	ULONG base;
	ULONG size;
	ULONG protect_flag;
};
struct struct_moudle {
	char name[MAX_PATH];
	uint64_t entry;
	uint64_t base;
	uint64_t size;
	std::vector<moudle_import> import_function;
	std::vector<moudle_export> export_function;
	std::vector<moudle_section> sections;
};
typedef PVOID(NTAPI *RtlImageDirectoryEntryToDataFn)(PVOID, BOOLEAN, USHORT, PULONG);