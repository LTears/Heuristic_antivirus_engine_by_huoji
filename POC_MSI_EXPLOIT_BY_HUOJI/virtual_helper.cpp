#include "head.h"
#include "head.h"
#include "virtual_helper.h"
/*
	virtual_helper: 设置底层系统虚拟化环境
*/
void init_descriptor64(SegmentDesctiptorX64* desc, uint64_t base, uint64_t limit, bool is_code, bool is_long_mode)
{
	desc->descriptor.all = 0;  //clear the descriptor
	desc->descriptor.fields.base_low = base;
	desc->descriptor.fields.base_mid = (base >> 16) & 0xff;
	desc->descriptor.fields.base_high = base >> 24;
	desc->base_upper32 = base >> 32;

	if (limit > 0xfffff) {
		limit >>= 12;
		desc->descriptor.fields.gran = 1;
	}

	desc->descriptor.fields.limit_low = limit & 0xffff;
	desc->descriptor.fields.limit_high = limit >> 16;

	desc->descriptor.fields.dpl = 0;
	desc->descriptor.fields.present = 1;
	desc->descriptor.fields.db = 1;   //64 bit
	desc->descriptor.fields.type = is_code ? 0xb : 3;
	desc->descriptor.fields.system = 1;  //code or data
	desc->descriptor.fields.l = is_long_mode ? 1 : 0;
}

sim_process virtual_helper::init_process_context(sim_process params_process)
{
	/*
		设置PEB
		代码没写完,以后再写设置进程PEB的东西
	*/
	params_process.context.peb.ImageBaseAddress = params_process.m_image_base;
	params_process.context.m_PebEnd = params_process.context.m_PebBase + AlignSize(sizeof(X64PEB), PAGE_SIZE);
	/*
		设置TEB
		代码没写完,以后再写设置进程TEB的东西
	*/
	params_process.context.m_TebEnd = params_process.context.m_TebBase + AlignSize(sizeof(X64TEB), PAGE_SIZE);
	uint64_t teb_alloc_size = AlignSize(sizeof(X64TEB), PAGE_SIZE);

	params_process.context.teb.ClientId.UniqueProcess = params_process.process_data.UniqueProcessId;
	params_process.context.teb.ClientId.UniqueThread = params_process.process_data.UniqueProcessId;
	params_process.context.teb.ProcessEnvironmentBlock = (X64PEB*)params_process.context.m_PebBase;

	params_process.context.teb.NtTib.StackBase = params_process.context.m_stack_base;
	params_process.context.teb.NtTib.StackLimit = params_process.context.m_stack_size;
	/*
		设置GS
	*/
	params_process.context.gs_base.teb = params_process.context.m_TebBase;
	uint64_t gs_alloc_size = AlignSize(sizeof(struct_gs_base), PAGE_SIZE);
	//__debugbreak();
	/*
		映射
	*/
	//peb
	uc_mem_map(g_global->uc_engine, params_process.context.m_PebBase, params_process.context.m_PebEnd - params_process.context.m_PebBase, UC_PROT_READ | UC_PROT_WRITE);
	uc_mem_write(g_global->uc_engine, params_process.context.m_PebBase, &params_process.context.peb, sizeof(X64PEB));
	//teb
	uc_mem_map(g_global->uc_engine, params_process.context.m_TebBase, params_process.context.m_TebEnd - params_process.context.m_TebBase, UC_PROT_READ | UC_PROT_WRITE);
	uc_mem_write(g_global->uc_engine, params_process.context.m_TebBase, &params_process.context.teb, sizeof(X64TEB));
	//gs
	uc_mem_map(g_global->uc_engine, params_process.context.m_gs_base, gs_alloc_size, UC_PROT_READ);
	uc_mem_write(g_global->uc_engine, params_process.context.m_gs_base, &params_process.context.gs_base, sizeof(struct_gs_base));
	/*
		//测试
		uint64_t read;
		auto error = uc_mem_read(g_global->uc_engine, g_global->gs_base, &read,0x8);
		printf("error: %d read: %08X \n", error, read);
	*/
	uc_x86_msr msr;
	msr.rid = (uint32_t)Msr::kIa32GsBase;
	msr.value = params_process.context.m_gs_base;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_MSR, &msr);
	return params_process;
}

void virtual_helper::init_virtual_processer() {
	uc_x86_mmr gdtr;

	uint64_t kpcr_base = 0xfffff00000000000ull;

	KPCR kpcr;

	memset(&kpcr, 0, sizeof(KPCR));

	gdtr.base = kpcr_base + offsetof(KPCR, gdt);
	gdtr.limit = sizeof(kpcr.gdt) - 1;

	//code segment
	init_descriptor64(&kpcr.gdt[1], 0, 0xffffffffffffffff, true, true);
	//data segment
	init_descriptor64(&kpcr.gdt[2], 0, 0xffffffffffffffff, false, true);
	//one page data segment simulate gs
	//init_descriptor64(&kpcr.gdt[3], 0x7efdd000, 0xfff, false, true);

	uc_mem_map(g_global->uc_engine, kpcr_base, PAGE_SIZE, UC_PROT_READ);
	uc_mem_write(g_global->uc_engine, kpcr_base, &kpcr, sizeof(KPCR));
	uc_reg_write(g_global->uc_engine, UC_X86_REG_GDTR, &gdtr);

	SegmentSelector cs = { 0 };
	cs.fields.index = 1;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_CS, &cs.all);

	SegmentSelector ds = { 0 };
	ds.fields.index = 2;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_DS, &ds.all);

	SegmentSelector ss = { 0 };
	ss.fields.index = 2;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_SS, &ss.all);

	SegmentSelector es = { 0 };
	es.fields.index = 2;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_ES, &es.all);

	SegmentSelector gs = { 0 };
	gs.fields.index = 2;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_GS, &gs.all);

	FlagRegister eflags = { 0 };
	eflags.fields.id = 1;
	eflags.fields.intf = 1;
	eflags.fields.reserved1 = 1;

	uc_reg_write(g_global->uc_engine, UC_X86_REG_EFLAGS, &eflags.all);

	uint64_t cr8 = 0;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_CR8, &cr8);
	/*
		映射 m_KSharedUserDataBase
	*/
	uint64_t m_KSharedUserDataBase = 0x7FFE0000;
	uint64_t m_KSharedUserDataEnd = 0x7FFE0FFF; //0x7FFE2000
	uint64_t m_KSharedUserDataSize = AlignSize(m_KSharedUserDataEnd - m_KSharedUserDataBase, PAGE_SIZE);
	
	uc_mem_map(g_global->uc_engine, m_KSharedUserDataBase, m_KSharedUserDataSize, UC_PROT_READ);
	uc_mem_write(g_global->uc_engine, m_KSharedUserDataBase, (void*)m_KSharedUserDataBase, m_KSharedUserDataSize);

	//映射一块不知道是什么东西的内存 在KUSER_SHARED_DATA下面
	uint64_t unk_memory = 0x7FFE1000;
	if (IsBadReadPtr(&unk_memory, PAGE_SIZE) == 0) {
		unk_memory = 0x7FFE9000;
	}
	uc_mem_map(g_global->uc_engine, unk_memory, PAGE_SIZE, UC_PROT_READ);
	uc_mem_write(g_global->uc_engine, unk_memory, (void*)(unk_memory), PAGE_SIZE);

}
sim_process virtual_helper::map_special_moudle(sim_process params_process, char* params_moudle_name) {
	DWORD64 params_moudle_base = (DWORD64)LoadLibraryA(params_moudle_name);
	printf("%s -> %08X \n", params_moudle_name, params_moudle_base);
	//PIMAGE_DOS_HEADER dos_head = (PIMAGE_DOS_HEADER)params_moudle_base;
	//PIMAGE_NT_HEADERS nt_head = (PIMAGE_NT_HEADERS)((LPBYTE)params_moudle_base + dos_head->e_lfanew);
	std::vector<moudle_import> import_data_dict;
	std::vector<moudle_export> export_data_dict = g_pe->get_export((PVOID)params_moudle_base);
	params_process.process_data.moudle_list = g_pe->push_to_virtual_helper(params_process.process_data.moudle_list,export_data_dict, import_data_dict, (char*)params_moudle_name, (uint64_t)params_moudle_base);
	return params_process;
}
/*
	跑PE
*/
void virtual_helper::run(sim_process params_process) {
	
	//分配堆栈
	uint64_t m_ImageEnd = params_process.m_image_base + params_process.m_nt_head->OptionalHeader.SizeOfImage;
	params_process.context.stack_buf = VirtualAlloc(NULL, params_process.context.m_stack_size, MEM_COMMIT, PAGE_READWRITE);
	memset(params_process.context.stack_buf, 0, params_process.context.m_stack_size);
	//初始化stack
	uc_mem_map(g_global->uc_engine, params_process.context.m_stack_base, params_process.context.m_stack_size, UC_PROT_READ | UC_PROT_WRITE);
	uc_mem_write(g_global->uc_engine, params_process.context.m_stack_base, params_process.context.stack_buf, params_process.context.m_stack_size);
	uc_mem_map(g_global->uc_engine, params_process.context.m_heap_base, params_process.context.m_heap_end - params_process.context.m_heap_base, UC_PROT_READ | UC_PROT_WRITE | UC_PROT_EXEC);

	//写寄存器
	uint64_t Rsp = params_process.context.m_stack_end - 64;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_RSP, &Rsp);
	uc_mem_write(g_global->uc_engine, Rsp, &m_ImageEnd, sizeof(m_ImageEnd));
	uc_mem_map(g_global->uc_engine, m_ImageEnd, 0x1000, UC_PROT_EXEC | UC_PROT_READ);
	
	//追踪代码
	uc_hook_add(g_global->uc_engine, &g_global->hook_code, UC_HOOK_CODE, call_track::handle_code_run, &params_process, 1, 0);
	uc_hook_add(g_global->uc_engine, &g_global->hook_mem, UC_HOOK_MEM_READ | UC_HOOK_MEM_WRITE | UC_HOOK_MEM_FETCH, call_track::handle_memory_read, &params_process, 1, 0);
	uc_hook_add(g_global->uc_engine, &g_global->hook_mem_unmap, UC_HOOK_MEM_FETCH_UNMAPPED | UC_HOOK_MEM_WRITE_UNMAPPED | UC_HOOK_MEM_READ_UNMAPPED, call_track::handle_memory_unmap_read, &params_process, 1, 0);

	//映射模块到虚拟机里

	//单独映射kernelbase.dll
	params_process = map_special_moudle(params_process, "kernelbase.dll");
	params_process = map_special_moudle(params_process, "ntdll.dll");

	//写pe文件到虚拟机里
	uc_mem_map(g_global->uc_engine, params_process.m_image_base, params_process.m_nt_head->OptionalHeader.SizeOfImage, UC_PROT_ALL);
	uc_mem_write(g_global->uc_engine, params_process.m_image_base, (void*)params_process.m_image_base, params_process.m_nt_head->OptionalHeader.SizeOfImage);
	printf("[PE] Map PE Base: %08X Size: %08X \n", params_process.m_image_base, params_process.m_nt_head->OptionalHeader.SizeOfImage);
	for (size_t i = 0; i < params_process.process_data.moudle_list.size(); i++)
	{
		printf("[PE][moudle_list] %s address: %08X size:%08X \n", params_process.process_data.moudle_list[i].name, params_process.process_data.moudle_list[i].base, params_process.process_data.moudle_list[i].size);
		//dll -> UC内存空间
		if (strcmp(params_process.process_data.moudle_list[i].name, params_process.process_data.ImageFileName) != 0) {
			uc_mem_map(g_global->uc_engine, params_process.process_data.moudle_list[i].base, params_process.process_data.moudle_list[i].size, UC_PROT_ALL);
			uc_mem_write(g_global->uc_engine, params_process.process_data.moudle_list[i].base, (void*)params_process.process_data.moudle_list[i].base, params_process.process_data.moudle_list[i].size);
		}
	}
	printf("[virtual_helper]EntryPoint: %08X \n", params_process.entry_point);
	auto err = uc_emu_start(g_global->uc_engine, params_process.m_image_base + params_process.entry_point, m_ImageEnd, 0, 0);
	printf("[virtual_helper]error : %d ", err);
}
