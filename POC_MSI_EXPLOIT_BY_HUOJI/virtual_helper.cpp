#include "head.h"
#include "head.h"
#include "virtual_helper.h"

void init_descriptor64(SegmentDesctiptorX64* desc, uint64_t base, uint64_t limit, bool is_code, bool is_long_mode)
{
	desc->descriptor.all = 0;  //clear the descriptor
	desc->descriptor.fields.base_low = base;
	desc->descriptor.fields.base_mid = (base >> 16) & 0xff;
	desc->descriptor.fields.base_high = base >> 24;
	desc->base_upper32 = base >> 32;

	if (limit > 0xfffff) {
		limit >>= 12;
		desc->descriptor.fields.gran = 1;
	}

	desc->descriptor.fields.limit_low = limit & 0xffff;
	desc->descriptor.fields.limit_high = limit >> 16;

	desc->descriptor.fields.dpl = 0;
	desc->descriptor.fields.present = 1;
	desc->descriptor.fields.db = 1;   //64 bit
	desc->descriptor.fields.type = is_code ? 0xb : 3;
	desc->descriptor.fields.system = 1;  //code or data
	desc->descriptor.fields.l = is_long_mode ? 1 : 0;
}

void virtual_helper::init_virtual_pte()
{
	for (size_t i = 0; i < moudle_list.size(); i++)
	{
		moudle_list[i].export_function.clear();
		moudle_list[i].import_function.clear();
	}
	moudle_list.clear();
	/*
	//hzqst的代码是直接把gs_base = teb_base了,有问题
	PEB peb = { 0 };
	m_PebBase = 0x90000ull;
	m_PebEnd = m_PebBase + AlignSize(sizeof(PEB), PAGE_SIZE);

	uc_mem_map(g_global->uc_engine, m_PebBase, m_PebEnd - m_PebBase, UC_PROT_READ);
	uc_mem_write(g_global->uc_engine, m_PebBase, &peb, sizeof(PEB));

	m_TebBase = 0x8000;
	m_TebEnd = m_TebBase + AlignSize(sizeof(X64TEB), PAGE_SIZE);
	uint64_t teb_alloc_size = AlignSize(sizeof(X64TEB), PAGE_SIZE);
	X64TEB teb = { 0 };
	teb.ClientId.UniqueProcess = 0x1337;
	teb.ClientId.UniqueThread = 0x1337;
	teb.ProcessEnvironmentBlock = (PPEB)m_PebBase;

	uc_mem_map(g_global->uc_engine, m_TebBase, m_TebEnd - m_TebBase, UC_PROT_READ);
	uc_mem_write(g_global->uc_engine, m_TebBase, &teb, sizeof(X64TEB));

	uc_x86_msr msr;
	msr.rid = (uint32_t)Msr::kIa32GsBase;
	msr.value = m_TebBase;

	uc_reg_write(g_global->uc_engine, UC_X86_REG_MSR, &msr);
	*/

	/*
		设置PEB
	*/
	PEB peb = { 0 };
	m_PebBase = 0x90000;
	m_PebEnd = m_PebBase + AlignSize(sizeof(PEB), PAGE_SIZE);
	/*
		设置TEB
	*/
	m_TebBase = 0x80000;
	m_TebEnd = m_TebBase + AlignSize(sizeof(X64TEB), PAGE_SIZE);
	uint64_t teb_alloc_size = AlignSize(sizeof(X64TEB), PAGE_SIZE);
	X64TEB teb = { 0 };
	teb.ClientId.UniqueProcess = 0x1337;
	teb.ClientId.UniqueThread = 0x1337;
	teb.ProcessEnvironmentBlock = (PPEB)m_PebBase;
	/*
		设置GS
	*/
	struct_gs_base gs_base = {0};
	gs_base.teb = m_TebBase;
	uint64_t gs_alloc_size = AlignSize(sizeof(struct_gs_base), PAGE_SIZE);
	//__debugbreak();
	/*
		映射
	*/
	//peb
	uc_mem_map(g_global->uc_engine, m_PebBase, m_PebEnd - m_PebBase, UC_PROT_READ);
	uc_mem_write(g_global->uc_engine, m_PebBase, &peb, sizeof(PEB));
	//teb
	uc_mem_map(g_global->uc_engine, m_TebBase, m_TebEnd - m_TebBase, UC_PROT_READ);
	uc_mem_write(g_global->uc_engine, m_TebBase, &teb, sizeof(X64TEB));
	//gs
	uc_mem_map(g_global->uc_engine, m_gs_base, gs_alloc_size, UC_PROT_READ);
	uc_mem_write(g_global->uc_engine, m_gs_base, &gs_base, sizeof(struct_gs_base));
	/*
		//测试
		uint64_t read;
		auto error = uc_mem_read(g_global->uc_engine, g_global->gs_base, &read,0x8);
		printf("error: %d read: %08X \n", error, read);
	*/
	uc_x86_msr msr;
	msr.rid = (uint32_t)Msr::kIa32GsBase;
	msr.value = m_gs_base;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_MSR, &msr);
}

void virtual_helper::init_virtual_processer() {
	uc_x86_mmr gdtr;

	uint64_t kpcr_base = 0xfffff00000000000ull;

	KPCR kpcr;

	memset(&kpcr, 0, sizeof(KPCR));

	gdtr.base = kpcr_base + offsetof(KPCR, gdt);
	gdtr.limit = sizeof(kpcr.gdt) - 1;

	//code segment
	init_descriptor64(&kpcr.gdt[1], 0, 0xffffffffffffffff, true, true);
	//data segment
	init_descriptor64(&kpcr.gdt[2], 0, 0xffffffffffffffff, false, true);
	//one page data segment simulate gs
	init_descriptor64(&kpcr.gdt[3], 0x7efdd000, 0xfff, false, true);

	uc_mem_map(g_global->uc_engine, kpcr_base, PAGE_SIZE, UC_PROT_READ);
	uc_mem_write(g_global->uc_engine, kpcr_base, &kpcr, sizeof(KPCR));
	uc_reg_write(g_global->uc_engine, UC_X86_REG_GDTR, &gdtr);

	SegmentSelector cs = { 0 };
	cs.fields.index = 1;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_CS, &cs.all);

	SegmentSelector ds = { 0 };
	ds.fields.index = 2;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_DS, &ds.all);

	SegmentSelector ss = { 0 };
	ss.fields.index = 2;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_SS, &ss.all);

	SegmentSelector es = { 0 };
	es.fields.index = 2;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_ES, &es.all);

	SegmentSelector gs = { 0 };
	gs.fields.index = 2;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_GS, &gs.all);

	FlagRegister eflags = { 0 };
	eflags.fields.id = 1;
	eflags.fields.intf = 1;
	eflags.fields.reserved1 = 1;

	uc_reg_write(g_global->uc_engine, UC_X86_REG_EFLAGS, &eflags.all);

	uint64_t cr8 = 0;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_CR8, &cr8);
}
void virtual_helper::map_special_moudle(char* params_moudle_name) {
	DWORD64 params_moudle_base = (DWORD64)LoadLibraryA(params_moudle_name);
	printf("%s -> %08X \n", params_moudle_name, params_moudle_base);
	//PIMAGE_DOS_HEADER dos_head = (PIMAGE_DOS_HEADER)params_moudle_base;
	//PIMAGE_NT_HEADERS nt_head = (PIMAGE_NT_HEADERS)((LPBYTE)params_moudle_base + dos_head->e_lfanew);
	std::vector<moudle_import> import_data_dict;
	std::vector<moudle_export> export_data_dict = g_pe->get_export((PVOID)params_moudle_base);;
	g_pe->push_to_virtual_helper(export_data_dict, import_data_dict, (char*)params_moudle_name, (uint64_t)params_moudle_base);
}
void virtual_helper::init_virtual_helper() {
	
	//分配堆栈
	uint64_t stack = 0x40000;
	size_t stack_size = 0x10000;
	uint64_t m_ImageEnd = g_pe->m_image_base + g_pe->m_nt_head->OptionalHeader.SizeOfImage;
	stack_buf = VirtualAlloc(NULL, stack_size, MEM_COMMIT, PAGE_READWRITE);

	m_stack_base = stack;
	m_stack_end = stack + stack_size;
	m_heap_base = 0x10000000ull;
	m_heap_end = m_heap_base + 0x1000000ull;

	memset(stack_buf, 0, stack_size);
	//初始化stack
	uc_mem_map(g_global->uc_engine, stack, stack_size, UC_PROT_READ | UC_PROT_WRITE);
	uc_mem_write(g_global->uc_engine, stack, stack_buf, stack_size);
	uc_mem_map(g_global->uc_engine, m_heap_base, m_heap_end - m_heap_base, UC_PROT_READ | UC_PROT_WRITE | UC_PROT_EXEC);
	//写pe文件到虚拟机里
	uc_mem_map(g_global->uc_engine, g_pe->m_image_base, g_pe->m_nt_head->OptionalHeader.SizeOfImage, UC_PROT_ALL);
	uc_mem_write(g_global->uc_engine, g_pe->m_image_base, (void*)g_pe->m_image_base, g_pe->m_nt_head->OptionalHeader.SizeOfImage);

	//写寄存器
	uint64_t Rsp = m_stack_end - 64;
	uc_reg_write(g_global->uc_engine, UC_X86_REG_RSP, &Rsp);
	uc_mem_write(g_global->uc_engine, Rsp, &m_ImageEnd, sizeof(m_ImageEnd));
	uc_mem_map(g_global->uc_engine, m_ImageEnd, 0x1000, UC_PROT_EXEC | UC_PROT_READ);
	
	//追踪代码
	uc_hook_add(g_global->uc_engine, &g_global->hook_code, UC_HOOK_CODE, call_track::handle_code_run, NULL, 1, 0);
	uc_hook_add(g_global->uc_engine, &g_global->hook_mem, UC_HOOK_MEM_READ | UC_HOOK_MEM_WRITE | UC_HOOK_MEM_FETCH, call_track::handle_memory_read, NULL, 1, 0);
	uc_hook_add(g_global->uc_engine, &g_global->hook_mem_unmap, UC_HOOK_MEM_FETCH_UNMAPPED | UC_HOOK_MEM_WRITE_UNMAPPED | UC_HOOK_MEM_READ_UNMAPPED, call_track::handle_memory_unmap_read, NULL, 1, 0);

	//映射模块到虚拟机里
	//单独映射kernelbase.dll
	map_special_moudle("kernelbase.dll");
	map_special_moudle("ntdll.dll");
	for (size_t i = 0; i < g_virtual->moudle_list.size(); i++)
	{
		printf("[PE][moudle_list] %s address: %08X size:%08X \n", g_virtual->moudle_list[i].name, g_virtual->moudle_list[i].base, g_virtual->moudle_list[i].size);
		//dll -> UC内存空间
		if (strcmp(g_virtual->moudle_list[i].name, "main.exe") != 0) {
			uc_mem_map(g_global->uc_engine, g_virtual->moudle_list[i].base, g_virtual->moudle_list[i].size, UC_PROT_ALL);
			uc_mem_write(g_global->uc_engine, g_virtual->moudle_list[i].base, (void*)g_virtual->moudle_list[i].base, g_virtual->moudle_list[i].size);
		}
		/*
		for (size_t j = 0; j < g_virtual->moudle_list[i].import_function.size(); j++)
		{
			printf("\t[import] %s address: %08X \n", g_virtual->moudle_list[i].import_function[j].name, g_virtual->moudle_list[i].import_function[j].function_address);
		}
		for (size_t j = 0; j < g_virtual->moudle_list[i].export_function.size(); j++)
		{
			printf("\t[export_function] %s address: %08X \n", g_virtual->moudle_list[i].export_function[j].name, g_virtual->moudle_list[i].export_function[j].function_address);
		}
		*/
	}

	printf("[virtual_helper]EntryPoint: %08X \n", g_pe->entry_point);
	auto err = uc_emu_start(g_global->uc_engine, g_pe->m_image_base + g_pe->entry_point, m_ImageEnd, 0, 0);
	printf("[virtual_helper]error : %d ", err);

}
