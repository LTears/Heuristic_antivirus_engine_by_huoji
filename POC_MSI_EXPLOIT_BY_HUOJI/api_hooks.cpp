#include "head.h"
#include "api_hooks.h"
namespace call_track {
	void print_string_hex(unsigned char* str, size_t len);
	void handle_code_run(uc_engine* uc, uint64_t address, uint32_t size, void* user_data);
	void handle_memory_read(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data);
	void hanlde_unmap_mem(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data);
	void handle_memory_unmap_read(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data);
	void handle_syscall(uc_engine* uc ,void* user_data);

	uint64_t LastMoudleBase;
	std::vector<std::string> call_link;
};

void call_track::print_string_hex(unsigned char* str, size_t len)
{
	unsigned char* c;
	for (c = str; c < str + len; c++) {
		printf("%02x ", *c & 0xff);
	}
	printf("\n");
}
void call_track::handle_memory_unmap_read(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data)
{
	sim_process* data = (sim_process*)user_data;
	uint64_t currt_rax;
	uc_reg_read(uc, UC_X86_REG_RAX, &currt_rax);
	uint64_t currt_rbx;
	uc_reg_read(uc, UC_X86_REG_RBX, &currt_rbx);
	printf("[handle_memory_unmap_read]excepting address: %p RAX: %p RBX: %p \n", address, currt_rax, currt_rbx);
	for each (auto iter in call_link)
	{
		printf("%s\n",iter.c_str());
	}
	/*
	uint64_t currt_rax;
	uc_reg_read(uc, UC_X86_REG_RAX, &currt_rax);
	uint64_t currt_rip;
	uc_reg_read(uc, UC_X86_REG_RIP, &currt_rip);
	//printf("[handle_memory_unmap_read]Handle address: %08X RAX: %p \n", address, currt_rax);
	struct_moudle m_code_speace_info = { 0 };
	sim_process* params_process = (sim_process*)user_data;
	if (find_code_speace(params_process->process_data.moudle_list, currt_rip, &m_code_speace_info)) {
		printf("[handle_memory_unmap_read]excepting at [%s.%08X]%08X RAX: %p \n", m_code_speace_info.name, currt_rip - m_code_speace_info.base, address, currt_rax);
	}
	else {
		printf("[handle_memory_unmap_read]excepting at %08X RAX: %p \n", address, currt_rax);
	}
	*/
	
}
void call_track::handle_syscall(uc_engine* uc, void* user_data)
{
	printf("\t=>[SYSCALL]=<\n");
	uint64_t rcx;
	uc_reg_read(uc, UC_X86_REG_RCX, &rcx);
	uint64_t rbx;
	uc_reg_read(uc, UC_X86_REG_RBX, &rbx);
	uint64_t r10;
	uc_reg_read(uc, UC_X86_REG_R10, &r10);
	uint64_t r9;
	uc_reg_read(uc, UC_X86_REG_R9, &r9);
	uint64_t rax;
	uc_reg_read(uc, UC_X86_REG_RAX, &rax);
	uint64_t rdx;
	uc_reg_read(uc, UC_X86_REG_RDX, &rdx);
	uint64_t rsi;
	uc_reg_read(uc, UC_X86_REG_RSI, &rsi);
	printf("\tRBX: %p \n\tRAX: %p \n\tRDX: %p \n\tR10: %p \n\tR9: %p \n\tRCX: %p \n\tRSI: %p \n", rbx, rax, rdx, r10, r9, rcx, rsi);
	uc_emu_stop(uc);
	for each (auto iter in call_link)
	{
		printf("%s\n", iter.c_str());
	}
}
void call_track::handle_memory_read(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data)
{
	uint64_t currt_rax;
	uc_reg_read(uc, UC_X86_REG_RAX, &currt_rax);
	printf("[handle_memory_read]Handle address: %p size: %p RAX: %p \n", address, size, currt_rax);
	uint64_t read;
	auto error = uc_mem_read(g_global->uc_engine, address, &read, size);
	printf("read : %d read: %p \n", error, read);
}
void call_track::hanlde_memory_write(uc_engine* uc, uc_mem_type type, uint64_t address, int size, int64_t value, void* user_data)
{
	uint64_t currt_rax;
	uc_reg_read(uc, UC_X86_REG_RAX, &currt_rax);
	printf("[hanlde_memory_write]Handle address: %p => %p size: %p RAX: %p \n", address,value ,size, currt_rax);

	uint64_t read;
	auto error = uc_mem_read(g_global->uc_engine, address, &read, size);
	printf("read : %d read: %p \n", error, read);
}
bool call_track::find_code_speace(std::vector<struct_moudle> params_moudle_list ,uint64_t params_rip, struct_moudle* out_info) {
	bool bFound = false;
	for (size_t i = 0; i < params_moudle_list.size(); i++)
	{
		if (params_rip >= params_moudle_list[i].base && params_rip <= params_moudle_list[i].base + params_moudle_list[i].size) {
			bFound = true;
			*out_info = params_moudle_list[i];
		}
	}
	return bFound;
}
void call_track::print_export_function(struct_moudle params_moudle_list, sim_process* params_simprocess, uint64_t params_rip) {
	for (size_t i = 0; i < params_moudle_list.export_function.size(); i++)
	{
		if (params_rip == params_moudle_list.base + params_moudle_list.export_function[i].function_address) {
			printf("\033[32m\t ==> Function Name: %s \n\033[0m", params_moudle_list.export_function[i].name);
			call_link.push_back(params_moudle_list.export_function[i].name);
			//__debugbreak();
		}
		//printf("name: %s addreess:%p \n" ,params_moudle_list.export_function[i].name,  params_moudle_list.base  + params_moudle_list.export_function[i].function_address);
	}
}
void call_track::handle_code_run(uc_engine* uc, uint64_t address, uint32_t size, void* user_data)
{
	sim_process* params_process = (sim_process*)user_data;
	uint64_t currt_rip;
	uc_reg_read(uc, UC_X86_REG_RIP, &currt_rip);
	struct_moudle m_code_speace_info = { 0 };
	if (find_code_speace(params_process->process_data.moudle_list ,currt_rip, &m_code_speace_info)) {
		if (LastMoudleBase != m_code_speace_info.base) {
			printf("\033[32m\t ==>[%s] Code Speace Switch to [%s] RIP: %p address: %p \n\033[0m", params_process->process_data.ImageFileName ,m_code_speace_info.name, currt_rip, address);
			print_export_function(m_code_speace_info, params_process, currt_rip);
		}
	}
	else {
		printf("\033[31m\t ==> [%s] Unknwon RIP: %p address: %p \n\033[0m", params_process->process_data.ImageFileName, currt_rip, address);
	}
	LastMoudleBase = m_code_speace_info.base;
	cs_insn insn;
	memset(&insn, 0, sizeof(insn));
	unsigned char codeBuffer[15];
	uc_mem_read(uc, address, codeBuffer, size);
	print_string_hex(codeBuffer, strlen((const char*)codeBuffer));
	uint64_t virtualBase = address;
	uint8_t* code = codeBuffer;
	size_t codeSize = size;
	cs_disasm_iter(g_global->hanlde_capstone, (const uint8_t**)&code, &codeSize, &virtualBase, &insn);
	printf("[%s]0x%08X :\t\t%s\t%s\n", m_code_speace_info.name, insn.address, insn.mnemonic, insn.op_str);
	/*
	uint64_t rcx;
	uc_reg_read(uc, UC_X86_REG_RCX, &rcx);
	uint64_t rbx;
	uc_reg_read(uc, UC_X86_REG_RBX, &rbx);
	uint64_t r10;
	uc_reg_read(uc, UC_X86_REG_R10, &r10);
	uint64_t r9;
	uc_reg_read(uc, UC_X86_REG_R9, &r9);
	uint64_t rax;
	uc_reg_read(uc, UC_X86_REG_RAX, &rax);
	uint64_t rdx;
	uc_reg_read(uc, UC_X86_REG_RDX, &rdx);
	uint64_t rsi;
	uc_reg_read(uc, UC_X86_REG_RSI, &rsi);
	printf("RBX: %p \nRAX: %p \nRDX: %p \nR10: %p \nR9: %p \nRCX: %p \nRSI: %p \n", rbx, rax,rdx, r10, r9, rcx, rsi);
	*/
	/*
	uint64_t m_next_rip = address + size;
	uint64_t currt_rip;
	uc_reg_read(uc, UC_X86_REG_RIP, &currt_rip);

	printf("[handle_code_run]Handle RIP: %08X address: %08X \n", currt_rip, address);
	if (address == 0x108C || address == 0x1038 || address == 0x1057 || address == 0x10AB || address == 0x10F7 || address == 0x111C) {
		uc_reg_write(uc, UC_X86_REG_RIP, &m_next_rip);
	}
	if (address == 0x1100) {
		unsigned char Byte[2] = { 0x74 };
		uc_mem_write(uc, address, Byte, 0x1);
	}
	*/
}
