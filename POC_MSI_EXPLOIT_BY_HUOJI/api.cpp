#include "head.h"
#include "api.h"
/*
x64上面默认的函数调用约定是fast call，也就是ABI是fast call。
前四个参数传递顺序是RCX，RDX，R8，R9，其余的参数通过压栈传递。注意这里有一个细节：前四个参数也是占用栈空间的，或者说，栈需要为前四个参数保留32个字节。
小于64位的参数传递时高位并不填充零，大于64位需要按照地址传递。
返回值在RAX
被调用函数不负责清栈
RAX，RCX，RDX，R8，R9，R10，R11是“易挥发”的，其余寄存器需要保护。
栈需要16字节对齐。
*/
bool api_emu::api_simulation_router(uc_engine* uc, std::string name, std::string moudle_name, uint64_t function_address, uint64_t call_address, sim_process* context) {
	bool handled = false;
	if (name == "GetSystemTimeAsFileTime") {
		GetSystemTimeAsFileTime(uc, function_address, context);
		handled = true;
		goto _exit;
	}
	if (name == "GetCurrentThreadId") {
		GetCurrentThreadId(uc, function_address, context);
		handled = true;
		goto _exit;
	}
	if (name == "GetCurrentProcessId") {
		GetCurrentProcessId(uc, function_address, context);
		handled = true;
		goto _exit;
	}
	if (name == "QueryPerformanceCounter") {
		FakeQueryPerformanceCounter(uc, function_address, context);
		handled = true;
		goto _exit;
	}
	//注意: __stdio_common_vfprintf 是 printf调用的,以后也许有用
	if (name == "_initterm_e" || name == "_initterm" || name == "_get_initial_narrow_environment" || name == "__p___argv" 
		|| name == "__p___argc" || name == "__acrt_iob_func" || name == "__stdio_common_vfprintf") {
		handled = true;
		goto _exit;
	}
	if (name == "GetModuleHandleW") {
		api_emu::GetModuleHandleW(uc, function_address, context);
		handled = true;
		goto _exit;
	}
	if (name == "exit") {
		api_emu::exit(uc, function_address, context);
		handled = true;
		goto _exit;
	}
	if (name == "LocalAlloc") {
		api_emu::LocalAlloc(uc, function_address, context);
		handled = true;
		goto _exit;
	}
_exit:
	analysis::log_function(uc, context, (char*)name.c_str(), (char*)moudle_name.c_str(), call_address, function_address);
	return handled;
}
uint64_t my_heap_alloc(ULONG AllocBytes, bool IsPageAlign, sim_process* context)
{
	uint64_t alloc = 0;

	for (size_t i = 0; i < context->heap_allocs.size(); ++i)
	{
		if (context->heap_allocs[i].free && context->heap_allocs[i].size >= AllocBytes)
		{
			//m_LastHeapAllocBytes = AllocBytes;
			context->heap_allocs[i].free = false;
			alloc = context->heap_allocs[i].base;
			break;
		}
	}

	if (!alloc)
	{
		for (size_t i = 0; i < context->heap_allocs.size(); ++i)
		{
			if (alloc < context->heap_allocs[i].base + context->heap_allocs[i].size)
				alloc = context->heap_allocs[i].base + context->heap_allocs[i].size;
		}

		if (!alloc)
			alloc = context->context.m_heap_base;

		if (IsPageAlign)
		{
			alloc = (alloc % 0x1000ull == 0) ? alloc : AlignSize(alloc, 0x1000ull);
			AllocBytes = (AllocBytes % 0x1000 == 0) ? AllocBytes : (ULONG)AlignSize(AllocBytes, 0x1000);
		}

		if (alloc + AllocBytes > context->context.m_heap_end)
		{
			//m_LastHeapAllocBytes = 0;
			return 0;
		}

		//m_LastHeapAllocBytes = AllocBytes;
		context->heap_allocs.emplace_back(alloc, AllocBytes);
	}

	return alloc;
}

void api_emu::LocalAlloc(uc_engine* uc, uint64_t address,sim_process* context)
{

	uint64_t alloc = 0;

	uint32_t ecx;
	auto err = uc_reg_read(uc, UC_X86_REG_ECX, &ecx);

	uint32_t edx;
	err = uc_reg_read(uc, UC_X86_REG_EDX, &edx);

	if (ecx == LMEM_FIXED)
	{
		alloc = my_heap_alloc(edx, false, context);
	}

	uc_reg_write(uc, UC_X86_REG_RAX, &alloc);
}

void api_emu::exit(uc_engine* uc, uint64_t address, sim_process* context) {
	uc_emu_stop(uc);
	analysis::print_process_functions(context, false);
}
void api_emu::GetSystemTimeAsFileTime(uc_engine* uc, uint64_t address, sim_process* context) {
	uint64_t rcx;
	FILETIME file_time;
	GetSystemTimeAsFileTime(&file_time);
	uc_reg_read(uc, UC_X86_REG_RCX, &rcx);
	uc_mem_write(uc, rcx, &file_time, sizeof(FILETIME));
}
void api_emu::GetCurrentThreadId(uc_engine* uc, uint64_t address, sim_process* context) {
	uc_reg_write(uc, UC_X86_REG_RAX, &context->process_data.UniqueProcessId);
}
void api_emu::GetCurrentProcessId(uc_engine* uc, uint64_t address, sim_process* context) {
	uc_reg_write(uc, UC_X86_REG_RAX, &context->process_data.UniqueProcessId);
}
void api_emu::GetModuleHandleW(uc_engine* uc, uint64_t address, sim_process* context) {
	uint64_t rcx;
	uint64_t return_data = NULL;
	uc_reg_read(uc, UC_X86_REG_RCX, &rcx);
	std::wstring moudle_name;
	if (rcx == NULL) {
		return_data = context->m_image_base;
	}
	else {
		if (tools::uc_read_wchar(uc, rcx, moudle_name))
		{
			std::string moudle_name_string;
			UnicodeToANSI(moudle_name, moudle_name_string);
			for (auto iter : context->process_data.moudle_list)
			{
				if (iter.name == moudle_name_string) {
					return_data = iter.base;
				}
			}

		}
	}
	printf("GetModuleHandleW rcx: %p lpModuleName: %ws return_data: %p \n", rcx, moudle_name.c_str(), return_data);

	uc_reg_write(uc, UC_X86_REG_RAX, &return_data);
}
void api_emu::FakeQueryPerformanceCounter(uc_engine* uc, uint64_t address, sim_process* context) {
	uint64_t rcx;
	LARGE_INTEGER data;
	BOOL origin_return_value = QueryPerformanceCounter(&data);
	uc_reg_read(uc, UC_X86_REG_RCX, &rcx);
	uc_mem_write(uc, rcx, &data, sizeof(LARGE_INTEGER));
	uc_reg_write(uc, UC_X86_REG_RAX, &origin_return_value);
}