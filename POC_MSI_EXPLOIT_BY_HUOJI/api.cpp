#include "head.h"
#include "api.h"
/*
x64上面默认的函数调用约定是fast call，也就是ABI是fast call。
前四个参数传递顺序是RCX，RDX，R8，R9，其余的参数通过压栈传递。注意这里有一个细节：前四个参数也是占用栈空间的，或者说，栈需要为前四个参数保留32个字节。
小于64位的参数传递时高位并不填充零，大于64位需要按照地址传递。
返回值在RAX
被调用函数不负责清栈
RAX，RCX，RDX，R8，R9，R10，R11是“易挥发”的，其余寄存器需要保护。
栈需要16字节对齐。

32栈传递 注意retN*4

*/
bool api_emu::api_simulation_router(uc_engine* uc, std::string name, std::string moudle_name, uint64_t function_address, uint64_t call_address, uint64_t code_size, sim_process* context) {
	bool handled = false;
	int params_num = -1;
	if (name == "GetSystemTimeAsFileTime") { //retn 4
		GetSystemTimeAsFileTime(uc, function_address, context);
		params_num = 4 + 4;
		handled = true;
		goto _exit;
	}
	if (name == "GetCurrentThreadId") { //ret
		GetCurrentThreadId(uc, function_address, context);
		params_num = 0;
		handled = true;
		goto _exit;
	}
	if (name == "GetCurrentProcessId") { //ret
		GetCurrentProcessId(uc, function_address, context);
		params_num = 0;
		handled = true;
		goto _exit;
	}
	if (name == "QueryPerformanceCounter") { //retn 4
		FakeQueryPerformanceCounter(uc, function_address, context);
		params_num = 4 + 4;
		handled = true;
		goto _exit;
	}
	if (name == "__stdio_common_vfprintf")
	{
		//ming tian zuo
		api_emu::Fake__stdio_common_vfprintf(uc, function_address, context);
		params_num = 4;
		handled = true;
		goto _exit;
	}
	//注意: __stdio_common_vfprintf 是 printf调用的,以后也许有用
	if (name == "_initterm_e" || name == "_initterm" || name == "_get_initial_narrow_environment" || name == "__p___argv"
		|| name == "__p___argc" || name == "__acrt_iob_func") {
		if (name == "__acrt_iob_func")
			params_num = 4;
		else
			params_num = 0;
		handled = true;
		goto _exit;
	}
	if (name == "GetModuleHandleW") { //retn 4
		api_emu::GetModuleHandleW(uc, function_address, context);
		params_num = 4 + 4;
		handled = true;
		goto _exit;
	}
	if (name == "GetModuleHandleA") { //retn 4
		api_emu::GetModuleHandleA(uc, function_address, context);
		params_num = 4 + 4;
		handled = true;
		goto _exit;
	}
	if (name == "exit") {
		api_emu::exit(uc, function_address, context);
		handled = true;
		goto _exit;
	}
	if (name == "LocalAlloc") {
		//32位没模拟
		api_emu::LocalAlloc(uc, function_address, context);
		params_num = 4 + 4;
		handled = true;
		goto _exit;
	}
	if (name == "IsProcessorFeaturePresent") { //retn 4
		api_emu::FakeIsProcessorFeaturePresent(uc, function_address, context);
		params_num = 4 + 4;
		handled = true;
		goto _exit;
	}
	if (name == "system") {
		api_emu::FakeSystem(uc, function_address, context);
		params_num = 4 + 4;
		handled = true;
		goto _exit;
	}
_exit:
	if (handled) {
		analysis::log_function(uc, context, (char*)name.c_str(), (char*)moudle_name.c_str(), call_address, function_address, params_num, code_size);
	}
	return handled;
}

uint64_t my_heap_alloc(ULONG AllocBytes, bool IsPageAlign, sim_process* context)
{
	uint64_t alloc = 0;

	for (size_t i = 0; i < context->heap_allocs.size(); ++i)
	{
		if (context->heap_allocs[i].free && context->heap_allocs[i].size >= AllocBytes)
		{
			//m_LastHeapAllocBytes = AllocBytes;
			context->heap_allocs[i].free = false;
			alloc = context->heap_allocs[i].base;
			break;
		}
	}

	if (!alloc)
	{
		for (size_t i = 0; i < context->heap_allocs.size(); ++i)
		{
			if (alloc < context->heap_allocs[i].base + context->heap_allocs[i].size)
				alloc = context->heap_allocs[i].base + context->heap_allocs[i].size;
		}
		if (!alloc)
			alloc = context->context.m_heap_base;

		if (IsPageAlign)
		{
			alloc = (alloc % 0x1000ull == 0) ? alloc : AlignSize(alloc, 0x1000ull);
			AllocBytes = (AllocBytes % 0x1000 == 0) ? AllocBytes : (ULONG)AlignSize(AllocBytes, 0x1000);
		}

		if (alloc + AllocBytes > context->context.m_heap_end)
		{
			//m_LastHeapAllocBytes = 0;
			return 0;
		}

		//m_LastHeapAllocBytes = AllocBytes;
		context->heap_allocs.emplace_back(alloc, AllocBytes);
	}

	return alloc;
}

/*
		_In_                                    unsigned __int64 _Options,
		_Inout_                                 FILE*            _Stream,
		_In_z_ _Printf_format_string_params_(2) char const*      _Format,
		_In_opt_                                _locale_t        _Locale,
												va_list          _ArgList
*/
//rcx rdx r8 r9
void api_emu::Fake__stdio_common_vfprintf(uc_engine* uc, uint64_t address, sim_process* context)
{
	//以后再做
	uint64_t params_address = NULL;
	params_address = 1;
	uc_reg_write(uc, context->is_x64 ? UC_X86_REG_RAX : UC_X86_REG_EAX, &params_address);
}
void api_emu::FakeSystem(uc_engine* uc, uint64_t address, sim_process* context) {
	uint32_t result = 0;
	uc_reg_write(uc, UC_X86_REG_RAX, &result);
}
void api_emu::FakeIsProcessorFeaturePresent(uc_engine* uc, uint64_t address, sim_process* context) {
	uint32_t rcx;
	uc_reg_read(uc, UC_X86_REG_ECX, &rcx);
	uint32_t result = IsProcessorFeaturePresent(rcx);
	uc_reg_write(uc, UC_X86_REG_RAX, &result);
}
void api_emu::LocalAlloc(uc_engine* uc, uint64_t address, sim_process* context)
{
	uint64_t alloc = 0;

	uint32_t ecx;
	auto err = uc_reg_read(uc, UC_X86_REG_ECX, &ecx);

	uint32_t edx;
	err = uc_reg_read(uc, UC_X86_REG_EDX, &edx);

	if (ecx == LMEM_FIXED)
	{
		alloc = my_heap_alloc(edx, false, context);
	}

	uc_reg_write(uc, UC_X86_REG_RAX, &alloc);
}

void api_emu::exit(uc_engine* uc, uint64_t address, sim_process* context) {
	uc_emu_stop(uc);
	analysis::print_process_functions(context, false);
}
void api_emu::GetSystemTimeAsFileTime(uc_engine* uc, uint64_t address, sim_process* context) {
	uint64_t rcx;
	FILETIME file_time;
	GetSystemTimeAsFileTime(&file_time);
	uc_reg_read(uc, UC_X86_REG_RCX, &rcx);
	uc_mem_write(uc, rcx, &file_time, sizeof(FILETIME));
}
void api_emu::GetCurrentThreadId(uc_engine* uc, uint64_t address, sim_process* context) {
	uc_reg_write(uc, UC_X86_REG_RAX, &context->process_data.UniqueProcessId);
}
void api_emu::GetCurrentProcessId(uc_engine* uc, uint64_t address, sim_process* context) {
	uc_reg_write(uc, UC_X86_REG_RAX, &context->process_data.UniqueProcessId);
}
/*
	16(%ebp) :第三个参数
	12(%ebp) :第二个参数
	8(%ebp) :第一个参数
	4(%ebp) :函数返回值
	0(%ebp) :老的%EBP(caller的%EBP)
	-4(%ebp) :第一个局部变量
	-8(%ebp) :第二个局部变量
	-12(%ebp):第三个局部变量
*/
void api_emu::GetModuleHandleA(uc_engine* uc, uint64_t address, sim_process* context) {
	uint64_t params_address = NULL;
	if (context->is_x64)
		uc_reg_read(uc, UC_X86_REG_RCX, &params_address);
	else {
		uint64_t ebp_address = 0;
		uc_reg_read(uc, UC_X86_REG_ESP, &ebp_address);
		ebp_address += 0x4;
		uc_mem_read(uc, ebp_address, &params_address, 0x4);
	}
	std::string moudle_name;
	if (params_address == NULL) {
		params_address = context->m_image_base;
	}
	else {
		if (tools::uc_read_char(uc, params_address, moudle_name))
		{
			for (auto iter : context->process_data.moudle_list)
			{
				if (iter.name == moudle_name) {
					params_address = iter.base;
				}
			}

		}
	}
	printf("\033[32m\t[!!!]GetModuleHandleA lpModuleName: %s return_data: %p \n\033[0m", moudle_name.c_str(), params_address);
	uc_reg_write(uc, context->is_x64 ? UC_X86_REG_RAX : UC_X86_REG_EAX, &params_address);
}
void api_emu::GetModuleHandleW(uc_engine* uc, uint64_t address, sim_process* context) {
	uint64_t params_address = 0;
	uint64_t return_data = NULL;
	if (context->is_x64)
		uc_reg_read(uc, UC_X86_REG_RCX, &params_address);
	else {
		uint64_t ebp_address = 0;
		uc_reg_read(uc, UC_X86_REG_ESP, &ebp_address);
		ebp_address += 0x4;
		uc_mem_read(uc, ebp_address, &params_address, 0x4);
	}
	std::wstring moudle_name;
	if (params_address == NULL) {
		return_data = context->m_image_base;
	}
	else {
		if (tools::uc_read_wchar(uc, params_address, moudle_name))
		{
			std::string moudle_name_string;
			UnicodeToANSI(moudle_name, moudle_name_string);
			for (auto iter : context->process_data.moudle_list)
			{
				if (iter.name == moudle_name_string) {
					return_data = iter.base;
				}
			}
		}
		else {
			printf("\033[31m\t ==> GetModuleHandleW can not read params \n\033[0m");

		}
	}
	printf("\033[32m\t[!!!]GetModuleHandleW params_address: %p lpModuleName: %ws return_data: %p \n\033[0m", params_address, moudle_name.c_str(), return_data);
	uc_reg_write(uc, context->is_x64 ? UC_X86_REG_RAX : UC_X86_REG_EAX, &return_data);
}
void api_emu::FakeQueryPerformanceCounter(uc_engine* uc, uint64_t address, sim_process* context) {
	uint64_t return_params_address = 0;
	LARGE_INTEGER data;
	BOOL origin_return_value = QueryPerformanceCounter(&data);
	if (context->is_x64) {
		uc_reg_read(uc, UC_X86_REG_RCX, &return_params_address);
	}
	else {
		uint64_t ebp_address = 0;
		uc_reg_read(uc, UC_X86_REG_ESP, &ebp_address);
		ebp_address += 0x4;
		uc_mem_read(uc, ebp_address, &return_params_address, 0x4);
	}
	uc_mem_write(uc, return_params_address, &data, sizeof(LARGE_INTEGER));
	uc_reg_write(uc, context->is_x64 ? UC_X86_REG_RAX : UC_X86_REG_EAX, &origin_return_value);
}